--- ../src-base/minecraft/net/minecraft/entity/Entity.java
+++ ../src-work/minecraft/net/minecraft/entity/Entity.java
@@ -87,6 +87,21 @@
 
 public abstract class Entity implements ICommandSender, net.minecraftforge.common.capabilities.ICapabilitySerializable<NBTTagCompound>
 {
+    // CraftBukkit start
+    private static final int CURRENT_LEVEL = 2;
+    static boolean isLevelAtLeast(NBTTagCompound tag, int level) {
+        return tag.hasKey("Bukkit.updateLevel") && tag.getInteger("Bukkit.updateLevel") >= level;
+    }
+
+    protected org.bukkit.craftbukkit.entity.CraftEntity bukkitEntity;
+
+    public org.bukkit.craftbukkit.entity.CraftEntity getBukkitEntity() {
+        if (bukkitEntity == null) {
+            bukkitEntity = org.bukkit.craftbukkit.entity.CraftEntity.getEntity(world.getServer(), this);
+        }
+        return bukkitEntity;
+    }
+    // CraftBukikt end
     private static final Logger LOGGER = LogManager.getLogger();
     private static final List<ItemStack> EMPTY_EQUIPMENT = Collections.<ItemStack>emptyList();
     private static final AxisAlignedBB ZERO_AABB = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
@@ -94,7 +109,7 @@
     private static int nextEntityID;
     private int entityId;
     public boolean preventEntitySpawning;
-    private final List<Entity> riddenByEntities;
+    public final List<Entity> riddenByEntities;  // Spigot - private -> public
     protected int rideCooldown;
     private Entity ridingEntity;
     public boolean forceSpawn;
@@ -137,8 +152,8 @@
     public float entityCollisionReduction;
     protected Random rand;
     public int ticksExisted;
-    private int fire;
-    protected boolean inWater;
+    public int fire; //Craftbukkit - private -> public
+    public boolean inWater; //Craftbukkit  - protected -> public
     public int hurtResistantTime;
     protected boolean firstUpdate;
     protected boolean isImmuneToFire;
@@ -172,7 +187,7 @@
     protected UUID entityUniqueID;
     protected String cachedUniqueIdString;
     private final CommandResultStats cmdResultStats;
-    protected boolean glowing;
+    public boolean glowing; //Craftbukkit - protected -> public
     private final Set<String> tags;
     private boolean isPositionDirty;
     private final double[] pistonDeltas;
@@ -182,6 +197,16 @@
      */
     public boolean updateBlocked;
 
+    // CraftBukkit start
+    public boolean valid;
+    public org.bukkit.projectiles.ProjectileSource projectileSource; // For projectiles only
+    public boolean forceExplosionKnockback; // SPIGOT-949
+
+    public float getBukkitYaw() {
+        return this.rotationYaw;
+    }
+    // CraftBukkit end
+
     public Entity(World worldIn)
     {
         this.entityId = nextEntityID++;
@@ -345,8 +370,35 @@
         }
     }
 
-    protected void setRotation(float yaw, float pitch)
+    public void setRotation(float yaw, float pitch) //Craftbukkit - protected -> public
     {
+        // CraftBukkit start - yaw was sometimes set to NaN, so we need to set it back to 0
+        if (Float.isNaN(yaw)) {
+            yaw = 0;
+        }
+
+        if (yaw == Float.POSITIVE_INFINITY || yaw == Float.NEGATIVE_INFINITY) {
+            if (this instanceof EntityPlayer) {
+                this.world.getServer().getLogger().warning(this.getName() + " was caught trying to crash the server with an invalid yaw");
+                ((org.bukkit.craftbukkit.entity.CraftPlayer) this.getBukkitEntity()).kickPlayer("Nope");
+            }
+            yaw = 0;
+        }
+
+        // pitch was sometimes set to NaN, so we need to set it back to 0
+        if (Float.isNaN(pitch)) {
+            pitch = 0;
+        }
+
+        if (pitch == Float.POSITIVE_INFINITY || pitch == Float.NEGATIVE_INFINITY) {
+            if (this instanceof EntityPlayer) {
+                this.world.getServer().getLogger().warning(this.getName() + " was caught trying to crash the server with an invalid pitch");
+                ((org.bukkit.craftbukkit.entity.CraftPlayer) this.getBukkitEntity()).kickPlayer("Nope");
+            }
+            pitch = 0;
+        }
+        // CraftBukkit end
+
         this.rotationYaw = yaw % 360.0F;
         this.rotationPitch = pitch % 360.0F;
     }
@@ -389,6 +441,50 @@
         this.onEntityUpdate();
     }
 
+    //Craftbukkit method TODO rework this completely
+    public void postTick() {
+        // No clean way to break out of ticking once the entity has been copied to a new world, so instead we move the portalling later in the tick cycle
+        if (!this.world.isRemote && this.world instanceof WorldServer) {
+            this.world.profiler.startSection("portal");
+            if (this.inPortal) {
+                MinecraftServer minecraftserver = this.world.getMinecraftServer();
+
+                if (true || minecraftserver.getAllowNether()) { // CraftBukkit
+                    if (!this.isRiding()) {
+                        int i = this.getMaxInPortalTime();
+
+                        if (this.portalCounter++ >= i) {
+                            this.portalCounter = i;
+                            this.timeUntilPortal = this.getPortalCooldown();
+                            byte b0;
+
+                            if (this.world.provider.getDimensionType().getId() == -1) {
+                                b0 = 0;
+                            } else {
+                                b0 = -1;
+                            }
+
+                            this.changeDimension(b0);
+                        }
+                    }
+
+                    this.inPortal = false;
+                }
+            } else {
+                if (this.portalCounter > 0) {
+                    this.portalCounter -= 4;
+                }
+
+                if (this.portalCounter < 0) {
+                    this.portalCounter = 0;
+                }
+            }
+
+            this.decrementTimeUntilPortal();
+            this.world.profiler.endSection();
+        }
+    }
+
     public void onEntityUpdate()
     {
         this.world.profiler.startSection("entityBaseTick");
@@ -409,7 +505,8 @@
         this.prevPosZ = this.posZ;
         this.prevRotationPitch = this.rotationPitch;
         this.prevRotationYaw = this.rotationYaw;
-
+        // Moved up to postTick TODO
+        //*
         if (!this.world.isRemote && this.world instanceof WorldServer)
         {
             this.world.profiler.startSection("portal");
@@ -462,7 +559,7 @@
             this.decrementTimeUntilPortal();
             this.world.profiler.endSection();
         }
-
+        //*/
         this.spawnRunningParticles();
         this.handleWaterMovement();
 
@@ -530,6 +627,26 @@
         if (!this.isImmuneToFire)
         {
             this.attackEntityFrom(DamageSource.LAVA, 4.0F);
+            // CraftBukkit start - Fallen in lava TODO: this event spams!
+            if (this instanceof EntityLiving) {
+                if (fire <= 0) {
+                    // not on fire yet
+                    // TODO: shouldn't be sending null for the block
+                    org.bukkit.block.Block damager = null; // ((WorldServer) this.l).getWorld().getBlockAt(i, j, k);
+                    org.bukkit.entity.Entity damagee = this.getBukkitEntity();
+                    org.bukkit.event.entity.EntityCombustEvent combustEvent = new org.bukkit.event.entity.EntityCombustByBlockEvent(damager, damagee, 15);
+                    this.world.getServer().getPluginManager().callEvent(combustEvent);
+
+                    if (!combustEvent.isCancelled()) {
+                        this.setFire(combustEvent.getDuration());
+                    }
+                } else {
+                    // This will be called every single tick the entity is in lava, so don't throw an event
+                    this.setFire(15);
+                }
+                return;
+            }
+            // CraftBukkit end - we also don't throw an event unless the object in lava is living, to save on some event calls
             this.setFire(15);
         }
     }
@@ -579,6 +696,22 @@
         }
         else
         {
+            /*// CraftBukkit start - Don't do anything if we aren't moving
+            // We need to do this regardless of whether or not we are moving thanks to portals
+            try {
+                this.doBlockCollisions();
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Checking entity block collision");
+                CrashReportCategory crashreportsystemdetails = crashreport.makeCategory("Entity being checked for collision");
+
+                this.addEntityCrashInfo(crashreportsystemdetails);
+                throw new ReportedException(crashreport);
+            }
+            // Check if we're moving
+            if (x == 0 && y == 0 && z == 0 && this.isBeingRidden() && this.isRiding()) {
+                return;
+            }
+            // CraftBukkit end*/
             if (type == MoverType.PISTON)
             {
                 long i = this.world.getTotalWorldTime();
@@ -912,6 +1045,26 @@
                 block.onLanded(this.world, this);
             }
 
+            if (collidedHorizontally && getBukkitEntity() instanceof org.bukkit.entity.Vehicle) {
+                org.bukkit.entity.Vehicle vehicle = (org.bukkit.entity.Vehicle) this.getBukkitEntity();
+                org.bukkit.block.Block bl = this.world.getWorld().getBlockAt(MathHelper.floor(this.posX), MathHelper.floor(this.posY), MathHelper.floor(this.posZ));
+
+                if (d2 > x) {
+                    bl = bl.getRelative(org.bukkit.block.BlockFace.EAST);
+                } else if (d2 < x) {
+                    bl = bl.getRelative(org.bukkit.block.BlockFace.WEST);
+                } else if (d4 > z) {
+                    bl = bl.getRelative(org.bukkit.block.BlockFace.SOUTH);
+                } else if (d4 < z) {
+                    bl = bl.getRelative(org.bukkit.block.BlockFace.NORTH);
+                }
+
+                if (bl.getType() != org.bukkit.Material.AIR) {
+                    org.bukkit.event.vehicle.VehicleBlockCollisionEvent event = new org.bukkit.event.vehicle.VehicleBlockCollisionEvent(vehicle, bl);
+                    world.getServer().getPluginManager().callEvent(event);
+                }
+            }
+
             if (this.canTriggerWalking() && (!this.onGround || !this.isSneaking() || !(this instanceof EntityPlayer)) && !this.isRiding())
             {
                 double d15 = this.posX - d10;
@@ -958,7 +1111,8 @@
                     this.nextFlap = this.playFlySound(this.distanceWalkedOnStepModified);
                 }
             }
-
+            // Move to the top of the method ///Lava-test - revert - TODO test all events here (VehicleCollision, portals...) - this fixes one of Quark's crashes
+            //*
             try
             {
                 this.doBlockCollisions();
@@ -970,6 +1124,7 @@
                 this.addEntityCrashInfo(crashreportcategory);
                 throw new ReportedException(crashreport);
             }
+            //*/
 
             boolean flag1 = this.isWet();
 
@@ -983,7 +1138,15 @@
 
                     if (this.fire == 0)
                     {
-                        this.setFire(8);
+                        //Craftbukkit start - event
+//                        this.setFire(8);
+                        org.bukkit.event.entity.EntityCombustEvent event = new org.bukkit.event.entity.EntityCombustByBlockEvent(null, getBukkitEntity(), 8);
+                        world.getServer().getPluginManager().callEvent(event);
+
+                        if (!event.isCancelled()) {
+                            this.setFire(event.getDuration());
+                        }
+                        //Craftbukkit end
                     }
                 }
             }
@@ -1369,6 +1532,13 @@
 
     public void setWorld(World worldIn)
     {
+        //Craftbukkit start - ??
+        if (world == null) {
+            setDead();
+            this.world = ((org.bukkit.craftbukkit.CraftWorld) org.bukkit.Bukkit.getServer().getWorlds().get(0)).getHandle();
+            return;
+        }
+        //Craftbukkit end
         this.world = worldIn;
     }
 
@@ -1687,6 +1857,16 @@
         {
             compound.setTag("Pos", this.newDoubleNBTList(this.posX, this.posY, this.posZ));
             compound.setTag("Motion", this.newDoubleNBTList(this.motionX, this.motionY, this.motionZ));
+            // CraftBukkit start - Checking for NaN pitch/yaw and resetting to zero
+            // TODO: make sure this is the best way to address this.
+            if (Float.isNaN(this.rotationYaw)) {
+                this.rotationYaw = 0;
+            }
+
+            if (Float.isNaN(this.rotationPitch)) {
+                this.rotationPitch = 0;
+            }
+            // CraftBukkit end
             compound.setTag("Rotation", this.newFloatNBTList(this.rotationYaw, this.rotationPitch));
             compound.setFloat("FallDistance", this.fallDistance);
             compound.setShort("Fire", (short)this.fire);
@@ -1696,7 +1876,11 @@
             compound.setBoolean("Invulnerable", this.invulnerable);
             compound.setInteger("PortalCooldown", this.timeUntilPortal);
             compound.setUniqueId("UUID", this.getUniqueID());
-
+            // CraftBukkit start
+            compound.setLong("WorldUUIDLeast", this.world.getSaveHandler().getUUID().getLeastSignificantBits());
+            compound.setLong("WorldUUIDMost", this.world.getSaveHandler().getUUID().getMostSignificantBits());
+            compound.setInteger("Bukkit.updateLevel", CURRENT_LEVEL);
+            // CraftBukkit end
             if (this.hasCustomName())
             {
                 compound.setString("CustomName", this.getCustomNameTag());
@@ -1784,20 +1968,26 @@
             this.motionY = nbttaglist2.getDoubleAt(1);
             this.motionZ = nbttaglist2.getDoubleAt(2);
 
+            if (!(getBukkitEntity() instanceof org.bukkit.entity.Vehicle)) //Lava-test move CB limit condition here
             if (Math.abs(this.motionX) > 10.0D)
             {
                 this.motionX = 0.0D;
             }
+            else if (Math.abs(this.motionX) > 100.0D) { this.motionX = 0.0D; } //Lava-test
 
+            if (!(getBukkitEntity() instanceof org.bukkit.entity.Vehicle)) //lava-test
             if (Math.abs(this.motionY) > 10.0D)
             {
                 this.motionY = 0.0D;
             }
+            else if (Math.abs(this.motionY) > 100.0D) { this.motionY = 0.0D; } //Lava-test
 
+            if (!(getBukkitEntity() instanceof org.bukkit.entity.Vehicle)) //Lava-test
             if (Math.abs(this.motionZ) > 10.0D)
             {
                 this.motionZ = 0.0D;
             }
+            else if (Math.abs(this.motionZ) > 100.0D) { this.motionZ = 0.0D; } //Lava-test
 
             this.posX = nbttaglist.getDoubleAt(0);
             this.posY = nbttaglist.getDoubleAt(1);
@@ -1869,6 +2059,40 @@
             {
                 this.setPosition(this.posX, this.posY, this.posZ);
             }
+
+            //Craftbukkit start
+            if (this instanceof EntityLiving) {
+                EntityLiving entity = (EntityLiving) this;
+
+                // Reset the persistence for tamed animals
+                if (entity instanceof net.minecraft.entity.passive.EntityTameable && !isLevelAtLeast(compound, 2) && !compound.getBoolean("PersistenceRequired")) {
+                    ((EntityLiving) entity).persistenceRequired = !(entity).canDespawn();
+                }
+            }
+
+            // Reset world
+            if (this instanceof EntityPlayer) {
+                org.bukkit.Server server = org.bukkit.Bukkit.getServer();
+                org.bukkit.World bworld = null;
+
+                // TODO: Remove World related checks, replaced with WorldUID
+                String worldName = compound.getString("world");
+
+                if (compound.hasKey("WorldUUIDMost") && compound.hasKey("WorldUUIDLeast")) {
+                    UUID uid = new UUID(compound.getLong("WorldUUIDMost"), compound.getLong("WorldUUIDLeast"));
+                    bworld = server.getWorld(uid);
+                } else {
+                    bworld = server.getWorld(worldName);
+                }
+
+                if (bworld == null) {
+                    EntityPlayer entityPlayer = (EntityPlayer) this;
+                    bworld = ((org.bukkit.craftbukkit.CraftServer) server).getServer().getWorldServer(entityPlayer.dimension).getWorld();
+                }
+
+                setWorld(bworld == null ? null : ((org.bukkit.craftbukkit.CraftWorld) bworld).getHandle());
+            }
+            //Craftbukkit end
         }
         catch (Throwable throwable)
         {
@@ -1885,7 +2109,7 @@
     }
 
     @Nullable
-    protected final String getEntityString()
+    public final String getEntityString() //Craftbukkit - protected -> public
     {
         ResourceLocation resourcelocation = EntityList.getKey(this);
         return resourcelocation == null ? null : resourcelocation.toString();
@@ -2110,6 +2334,31 @@
         }
         else
         {
+            //Craftbukkit start
+            com.google.common.base.Preconditions.checkState(!passenger.riddenByEntities.contains(this), "Circular entity riding! %s %s", this, passenger);
+
+            org.bukkit.craftbukkit.entity.CraftEntity craft = (org.bukkit.craftbukkit.entity.CraftEntity) passenger.getBukkitEntity().getVehicle();
+            Entity orig = craft == null ? null : craft.getHandle();
+            if (getBukkitEntity() instanceof org.bukkit.entity.Vehicle && passenger.getBukkitEntity() instanceof org.bukkit.entity.LivingEntity && passenger.world.isChunkLoaded_CB((int) passenger.posX >> 4, (int) passenger.posZ >> 4, false)) { // Boolean not used
+                org.bukkit.event.vehicle.VehicleEnterEvent event = new org.bukkit.event.vehicle.VehicleEnterEvent(
+                    (org.bukkit.entity.Vehicle) getBukkitEntity(),
+                    passenger.getBukkitEntity()
+                );
+                org.bukkit.Bukkit.getPluginManager().callEvent(event);
+                org.bukkit.craftbukkit.entity.CraftEntity craftn = (org.bukkit.craftbukkit.entity.CraftEntity) passenger.getBukkitEntity().getVehicle();
+                Entity n = craftn == null ? null : craftn.getHandle();
+                if (event.isCancelled() || n != orig) {
+                    return;
+                }
+            }
+            //Craftbukkit end
+            // Spigot start
+            org.spigotmc.event.entity.EntityMountEvent event = new org.spigotmc.event.entity.EntityMountEvent(passenger.getBukkitEntity(), this.getBukkitEntity());
+            org.bukkit.Bukkit.getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                return;
+            }
+            // Spigot end
             if (!this.world.isRemote && passenger instanceof EntityPlayer && !(this.getControllingPassenger() instanceof EntityPlayer))
             {
                 this.riddenByEntities.add(0, passenger);
@@ -2129,6 +2378,23 @@
         }
         else
         {
+            //Craftbukkit start
+            org.bukkit.craftbukkit.entity.CraftEntity craft = (org.bukkit.craftbukkit.entity.CraftEntity) passenger.getBukkitEntity().getVehicle();
+            Entity orig = craft == null ? null : craft.getHandle();
+            if (getBukkitEntity() instanceof org.bukkit.entity.Vehicle && passenger.getBukkitEntity() instanceof org.bukkit.entity.LivingEntity) {
+                org.bukkit.event.vehicle.VehicleExitEvent event = new org.bukkit.event.vehicle.VehicleExitEvent(
+                    (org.bukkit.entity.Vehicle) getBukkitEntity(),
+                    (org.bukkit.entity.LivingEntity) passenger.getBukkitEntity()
+                );
+                org.bukkit.Bukkit.getPluginManager().callEvent(event);
+                org.bukkit.craftbukkit.entity.CraftEntity craftn = (org.bukkit.craftbukkit.entity.CraftEntity) passenger.getBukkitEntity().getVehicle();
+                Entity n = craftn == null ? null : craftn.getHandle();
+                if (event.isCancelled() || n != orig) {
+                    return;
+                }
+            }
+            org.bukkit.Bukkit.getPluginManager().callEvent( new org.spigotmc.event.entity.EntityDismountEvent(passenger.getBukkitEntity(), this.getBukkitEntity())); // Spigot
+            //Craftbukkit end
             this.riddenByEntities.remove(passenger);
             passenger.rideCooldown = 60;
         }
@@ -2325,12 +2591,12 @@
         this.setFlag(5, invisible);
     }
 
-    protected boolean getFlag(int flag)
+    public boolean getFlag(int flag) //Craftbukkit - protected -> public
     {
         return (((Byte)this.dataManager.get(FLAGS)).byteValue() & 1 << flag) != 0;
     }
 
-    protected void setFlag(int flag, boolean set)
+    public void setFlag(int flag, boolean set) //Craftbukkit - protected -> public
     {
         byte b0 = ((Byte)this.dataManager.get(FLAGS)).byteValue();
 
@@ -2351,17 +2617,57 @@
 
     public void setAir(int air)
     {
+        //Craftbukkit start - event
+        org.bukkit.event.entity.EntityAirChangeEvent event = new org.bukkit.event.entity.EntityAirChangeEvent(this.getBukkitEntity(), air);
+        event.getEntity().getServer().getPluginManager().callEvent(event);
+        if (event.isCancelled()) {
+            return;
+        }
+        air = event.getAmount();
+        //Craftbukkit end
         this.dataManager.set(AIR, Integer.valueOf(air));
     }
 
-    public void onStruckByLightning(EntityLightningBolt lightningBolt)
+    public void onStruckByLightning(@Nullable EntityLightningBolt lightningBolt) //Craftbukkit - add @Nullable
     {
+        //Craftbukkit start - events
+        if (lightningBolt == null)
+            lightningBolt = new EntityLightningBolt(this.world, this.posX, this.posY, this.posZ, false);
+        final org.bukkit.entity.Entity thisBukkitEntity = this.getBukkitEntity();
+        final org.bukkit.entity.Entity stormBukkitEntity = lightningBolt.getBukkitEntity();
+        final org.bukkit.plugin.PluginManager pluginManager = org.bukkit.Bukkit.getPluginManager();
+
+        if (thisBukkitEntity instanceof org.bukkit.entity.Hanging) {
+            org.bukkit.event.hanging.HangingBreakByEntityEvent hangingEvent = new org.bukkit.event.hanging.HangingBreakByEntityEvent((org.bukkit.entity.Hanging) thisBukkitEntity, stormBukkitEntity);
+            pluginManager.callEvent(hangingEvent);
+
+            if (hangingEvent.isCancelled()) {
+                return;
+            }
+        }
+
+        if (this.isImmuneToFire) {
+            return;
+        }
+        org.bukkit.craftbukkit.event.CraftEventFactory.entityDamage = lightningBolt;
+        if (!this.attackEntityFrom(DamageSource.LIGHTNING_BOLT, 5.0F)) {
+            org.bukkit.craftbukkit.event.CraftEventFactory.entityDamage = null;
+            return;
+        }
+        //Craftbukkit end
         this.attackEntityFrom(DamageSource.LIGHTNING_BOLT, 5.0F);
         ++this.fire;
 
         if (this.fire == 0)
         {
-            this.setFire(8);
+            // CraftBukkit start - Call a combust event when lightning strikes
+            // this.setFire(8);
+            org.bukkit.event.entity.EntityCombustByEntityEvent entityCombustEvent = new org.bukkit.event.entity.EntityCombustByEntityEvent(stormBukkitEntity, thisBukkitEntity, 8);
+            pluginManager.callEvent(entityCombustEvent);
+            if (!entityCombustEvent.isCancelled()) {
+                this.setFire(entityCombustEvent.getDuration());
+            }
+            // CraftBukkit end
         }
     }
 
@@ -2551,20 +2857,75 @@
             if (!net.minecraftforge.common.ForgeHooks.onTravelToDimension(this, dimensionIn)) return null;
             this.world.profiler.startSection("changeDimension");
             MinecraftServer minecraftserver = this.getServer();
-            int i = this.dimension;
-            WorldServer worldserver = minecraftserver.getWorld(i);
-            WorldServer worldserver1 = minecraftserver.getWorld(dimensionIn);
-            this.dimension = dimensionIn;
+            // CraftBukkit start - Move logic into new function "teleportTo(Location,boolean)" ///Lava-test - TODO rework this mess with teleporting
+            // int i = this.dimension;
+            // WorldServer worldserver = minecraftserver.getWorld(i);
+            // WorldServer worldserver1 = minecraftserver.getWorld(dimensionIn);
+            WorldServer exitWorld = null;
+            if (this.dimension < org.bukkit.craftbukkit.CraftWorld.CUSTOM_DIMENSION_OFFSET) { // Plugins must specify exit from custom Bukkit worlds
+                // Only target existing worlds (compensate for allow-nether/allow-end as false)
+                for (WorldServer world : minecraftserver.worlds) {
+                    if (world.dimension == dimensionIn) {
+                        exitWorld = world;
+                    }
+                }
+            }
 
+            BlockPos blockposition = null; // PAIL: CHECK
+            org.bukkit.Location enter = this.getBukkitEntity().getLocation();
+            org.bukkit.Location exit;
+            if (exitWorld != null) {
+                if (blockposition != null) {
+                    exit = new org.bukkit.Location(exitWorld.getWorld(), blockposition.getX(), blockposition.getY(), blockposition.getZ());
+                } else {
+                    exit = minecraftserver.getPlayerList().calculateTarget(enter, minecraftserver.getWorld(dimensionIn));
+                }
+            }
+            else {
+                exit = null;
+            }
+            boolean useTravelAgent = exitWorld != null && !(this.dimension == 1 && exitWorld.dimension == 1); // don't use agent for custom worlds or return from THE_END
+
+            org.bukkit.TravelAgent agent = exit != null ? (org.bukkit.TravelAgent) ((org.bukkit.craftbukkit.CraftWorld) exit.getWorld()).getHandle().getDefaultTeleporter() : org.bukkit.craftbukkit.CraftTravelAgent.DEFAULT; // return arbitrary TA to compensate for implementation dependent plugins
+            boolean oldCanCreate = agent.getCanCreatePortal();
+            agent.setCanCreatePortal(false); // General entities cannot create portals
+
+            org.bukkit.event.entity.EntityPortalEvent event = new org.bukkit.event.entity.EntityPortalEvent(this.getBukkitEntity(), enter, exit, agent);
+            event.useTravelAgent(useTravelAgent);
+            event.getEntity().getServer().getPluginManager().callEvent(event);
+            if (event.isCancelled() || event.getTo() == null || event.getTo().getWorld() == null || !this.isEntityAlive()) {
+                agent.setCanCreatePortal(oldCanCreate);
+                return null;
+            }
+            exit = event.useTravelAgent() ? event.getPortalTravelAgent().findOrCreate(event.getTo()) : event.getTo();
+            agent.setCanCreatePortal(oldCanCreate);
+
+            // Need to make sure the profiler state is reset afterwards (but we still want to time the call)
+            Entity entity = this.teleportTo(exit, true);
+            this.world.profiler.endSection();
+            return entity;
+        }
+        return null;
+    }
+
+    public Entity teleportTo(org.bukkit.Location exit, boolean portal) { //TODO rework
+        if (true) {
+            WorldServer worldserver = ((org.bukkit.craftbukkit.CraftWorld) getBukkitEntity().getLocation().getWorld()).getHandle();
+            WorldServer worldserver1 = ((org.bukkit.craftbukkit.CraftWorld) exit.getWorld()).getHandle();
+            int i = worldserver1.dimension;
+            this.dimension = i;
+            /* CraftBukkit start - TODO: Check if we need this
             if (i == 1 && dimensionIn == 1 && teleporter.isVanilla())
             {
                 worldserver1 = minecraftserver.getWorld(0);
                 this.dimension = 0;
             }
+            // CraftBukkit end */
 
             this.world.removeEntity(this);
             this.isDead = false;
             this.world.profiler.startSection("reposition");
+            /* CraftBukkit start - Handled in calculateTarget
             BlockPos blockpos;
 
             if (dimensionIn == 1 && teleporter.isVanilla())
@@ -2596,8 +2957,12 @@
                 teleporter.placeEntity(worldserver1, this, f);
                 blockpos = new BlockPos(this);
             }
+            // CraftBukkit end */
 
-            worldserver.updateEntityWithOptionalForce(this, false);
+            // worldserver.updateEntityWithOptionalForce(this, false); // Handled in repositionEntity
+            // CraftBukkit start - Ensure chunks are loaded in case TravelAgent is not used which would initially cause chunks to load during find/create
+            // minecraftserver.getPlayerList().changeWorld(this, j, worldserver, worldserver1);
+            worldserver1.getMinecraftServer().getPlayerList().repositionEntity(this, exit, portal);
             this.world.profiler.endStartSection("reloading");
             Entity entity = EntityList.newEntity(this.getClass(), worldserver1);
 
@@ -2605,6 +2970,7 @@
             {
                 entity.copyDataFromOld(this);
 
+                /* CraftBukkit start - We need to do this...
                 if (i == 1 && dimensionIn == 1 && teleporter.isVanilla())
                 {
                     BlockPos blockpos1 = worldserver1.getTopSolidOrLiquidBlock(worldserver1.getSpawnPoint());
@@ -2614,19 +2980,28 @@
                 {
                     entity.moveToBlockPosAndAngles(blockpos, entity.rotationYaw, entity.rotationPitch);
                 }
+                // CraftBukkit end */
 
                 boolean flag = entity.forceSpawn;
                 entity.forceSpawn = true;
                 worldserver1.spawnEntity(entity);
                 entity.forceSpawn = flag;
                 worldserver1.updateEntityWithOptionalForce(entity, false);
+                // CraftBukkit start - Forward the CraftEntity to the new entity
+                this.getBukkitEntity().setHandle(entity);
+                entity.bukkitEntity = this.getBukkitEntity();
+
+                if (this instanceof EntityLiving) {
+                    ((EntityLiving) this).clearLeashed(true, false); // Unleash to prevent duping of leads.
+                }
+                // CraftBukkit end
             }
 
             this.isDead = true;
             this.world.profiler.endSection();
             worldserver.resetUpdateEntityTick();
             worldserver1.resetUpdateEntityTick();
-            this.world.profiler.endSection();
+            // this.world.profiler.endSection(); // CraftBukkit: Moved up to keep balanced
             return entity;
         }
         else
@@ -2838,7 +3213,28 @@
 
     public void setEntityBoundingBox(AxisAlignedBB bb)
     {
+        //Craftbukkit? start - ????
+        double a = bb.minX,
+            b = bb.minY,
+            c = bb.minZ,
+            d = bb.maxX,
+            e = bb.maxY,
+            f = bb.maxZ;
+        double len = bb.maxX - bb.minX;
+        if (len < 0) d = a;
+        if (len > 64) d = a + 64.0;
+
+        len = bb.maxY - bb.minY;
+        if (len < 0) e = b;
+        if (len > 64) e = b + 64.0;
+
+        len = bb.maxZ - bb.minZ;
+        if (len < 0) f = c;
+        if (len > 64) f = c + 64.0;
+        bb = new AxisAlignedBB(a, b, c, d, e, f);
+        //Craftbukkit end
         this.boundingBox = bb;
+        
     }
 
     public float getEyeHeight()
@@ -3319,7 +3715,7 @@
         return SoundCategory.NEUTRAL;
     }
 
-    protected int getFireImmuneTicks()
+    public int getFireImmuneTicks() //Craftbukkit - protected -> public
     {
         return 1;
     }
