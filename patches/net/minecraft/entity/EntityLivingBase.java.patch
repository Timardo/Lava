--- ../src-base/minecraft/net/minecraft/entity/EntityLivingBase.java
+++ ../src-work/minecraft/net/minecraft/entity/EntityLivingBase.java
@@ -84,12 +84,12 @@
     private static final AttributeModifier SPRINTING_SPEED_BOOST = (new AttributeModifier(SPRINTING_SPEED_BOOST_ID, "Sprinting speed boost", 0.30000001192092896D, 2)).setSaved(false);
     public static final net.minecraft.entity.ai.attributes.IAttribute SWIM_SPEED = new net.minecraft.entity.ai.attributes.RangedAttribute(null, "forge.swimSpeed", 1.0D, 0.0D, 1024.0D).setShouldWatch(true);
     protected static final DataParameter<Byte> HAND_STATES = EntityDataManager.<Byte>createKey(EntityLivingBase.class, DataSerializers.BYTE);
-    private static final DataParameter<Float> HEALTH = EntityDataManager.<Float>createKey(EntityLivingBase.class, DataSerializers.FLOAT);
+    public static final DataParameter<Float> HEALTH = EntityDataManager.<Float>createKey(EntityLivingBase.class, DataSerializers.FLOAT); //Craftbukkit - private -> public
     private static final DataParameter<Integer> POTION_EFFECTS = EntityDataManager.<Integer>createKey(EntityLivingBase.class, DataSerializers.VARINT);
     private static final DataParameter<Boolean> HIDE_PARTICLES = EntityDataManager.<Boolean>createKey(EntityLivingBase.class, DataSerializers.BOOLEAN);
     private static final DataParameter<Integer> ARROW_COUNT_IN_ENTITY = EntityDataManager.<Integer>createKey(EntityLivingBase.class, DataSerializers.VARINT);
     private AbstractAttributeMap attributeMap;
-    private final CombatTracker _combatTracker = new CombatTracker(this);
+    public CombatTracker _combatTracker = new CombatTracker(this); //Craftbukkit - private final -> public
     private final Map<Potion, PotionEffect> activePotionsMap = Maps.<Potion, PotionEffect>newHashMap();
     private final NonNullList<ItemStack> handInventory = NonNullList.<ItemStack>withSize(2, ItemStack.EMPTY);
     private final NonNullList<ItemStack> armorArray = NonNullList.<ItemStack>withSize(4, ItemStack.EMPTY);
@@ -117,9 +117,9 @@
     public float rotationYawHead;
     public float prevRotationYawHead;
     public float jumpMovementFactor = 0.02F;
-    protected EntityPlayer attackingPlayer;
+    public EntityPlayer attackingPlayer; //Craftbukkit - protected -> public
     protected int recentlyHit;
-    protected boolean dead;
+    public boolean dead; //Lava-test - protected -> public TODO create getter instead?
     protected int idleTime;
     protected float prevOnGroundSpeedFactor;
     protected float onGroundSpeedFactor;
@@ -127,7 +127,7 @@
     protected float prevMovedDistance;
     protected float unused180;
     protected int scoreValue;
-    protected float lastDamage;
+    public float lastDamage; //Craftbukkit - protected -> public
     protected boolean isJumping;
     public float moveStrafing;
     public float moveVertical;
@@ -139,9 +139,9 @@
     protected double interpTargetZ;
     protected double interpTargetYaw;
     protected double interpTargetPitch;
-    private boolean potionsNeedUpdate = true;
-    private EntityLivingBase revengeTarget;
-    private int revengeTimer;
+    public boolean potionsNeedUpdate = true; //Craftbukkit - private -> public
+    public EntityLivingBase revengeTarget; //Craftbukkit - private -> public
+    public int revengeTimer; //Craftbukkit - private -> public
     private EntityLivingBase lastAttackedEntity;
     private int lastAttackedEntityTime;
     private float landMovementFactor;
@@ -154,6 +154,15 @@
     private DamageSource lastDamageSource;
     private long lastDamageStamp;
 
+    // CraftBukkit start
+    public int expToDrop;
+    public int maxAirTicks = 300;
+    public java.util.ArrayList<org.bukkit.inventory.ItemStack> drops = new java.util.ArrayList<>();
+    public org.bukkit.craftbukkit.attribute.CraftAttributeMap craftAttributes;
+    public boolean collides = true;
+    public boolean canPickUpLootCB;
+    // CraftBukkit end
+
     public void onKillCommand()
     {
         this.attackEntityFrom(DamageSource.OUT_OF_WORLD, Float.MAX_VALUE);
@@ -163,7 +172,10 @@
     {
         super(worldIn);
         this.applyEntityAttributes();
-        this.setHealth(this.getMaxHealth());
+        // CraftBukkit start - setHealth(getMaxHealth()) inlined and simplified to skip the instanceof check for EntityPlayer, as getBukkitEntity() is not initialized in constructor
+        //this.setHealth(this.getMaxHealth());
+        this.dataManager.set(EntityLiving.HEALTH, (float) this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).getAttributeValue()); ///Lava-test - reverting causes bad packet and NPE TODO find out why
+        //Craftbukkit end
         this.preventEntitySpawning = true;
         this.randomUnused1 = (float)((Math.random() + 1.0D) * 0.009999999776482582D);
         this.setPosition(this.posX, this.posY, this.posZ);
@@ -208,7 +220,14 @@
                 double d0 = Math.min((double)(0.2F + f / 15.0F), 2.5D);
                 int i = (int)(150.0D * d0);
                 if (!state.getBlock().addLandingEffects(state, (WorldServer)this.world, pos, state, this, i))
+                {
+                    // CraftBukkit start - visiblity api
+                    if (this instanceof EntityPlayer) {
+                        ((WorldServer) this.world).sendParticles((EntityPlayerMP) this, EnumParticleTypes.BLOCK_DUST, false, this.posX, this.posY, this.posZ, i, 0.0D, 0.0D, 0.0D, 0.15000000596046448D, new int[]{Block.getStateId(state)});
+                    } else
                 ((WorldServer)this.world).spawnParticle(EnumParticleTypes.BLOCK_DUST, this.posX, this.posY, this.posZ, i, 0.0D, 0.0D, 0.0D, 0.15000000596046448D, Block.getStateId(state));
+                    // CraftBukkit end
+                }
             }
         }
 
@@ -260,7 +279,12 @@
         {
             if (!this.isInsideOfMaterial(Material.WATER))
             {
-                this.setAir(300);
+                // CraftBukkit start - Only set if needed to work around a DataWatcher inefficiency
+                // this.setAir(300);
+                if (this.getAir() != 300) {
+                    this.setAir(maxAirTicks);
+                }
+                // CraftBukkit end
             }
             else
             {
@@ -359,6 +383,17 @@
         this.world.profiler.endSection();
     }
 
+    // CraftBukkit method used in death events TODO completely rework death events
+    public int getExpReward() {
+        int exp = this.getExperiencePoints(this.attackingPlayer);
+
+        if (!this.world.isRemote && (this.recentlyHit > 0 || this.isPlayer()) && this.canDropLoot() && this.world.getGameRules().getBoolean("doMobLoot")) {
+            return exp;
+        } else {
+            return 0;
+        }
+    }
+
     protected void frostWalk(BlockPos pos)
     {
         int i = EnchantmentHelper.getMaxEnchantmentLevel(Enchantments.FROST_WALKER, this);
@@ -378,19 +413,24 @@
     {
         ++this.deathTime;
 
-        if (this.deathTime == 20)
+        if (this.deathTime >= 20 && !this.isDead) // CraftBukkit - (this.deathTime == 20) -> (this.deathTime >= 20 && !this.isDead)
         {
-            if (!this.world.isRemote && (this.isPlayer() || this.recentlyHit > 0 && this.canDropLoot() && this.world.getGameRules().getBoolean("doMobLoot")))
-            {
-                int i = this.getExperiencePoints(this.attackingPlayer);
+            //Craftbukkit start - ??
+            // if (!this.world.isRemote && (this.isPlayer() || this.recentlyHit > 0 && this.canDropLoot() && this.world.getGameRules().getBoolean("doMobLoot"))) {
+            //int i = this.getExperiencePoints(this.attackingPlayer);
+            int i = this.expToDrop;
+            //Craftbukkit end
                 i = net.minecraftforge.event.ForgeEventFactory.getExperienceDrop(this, this.attackingPlayer, i);
                 while (i > 0)
                 {
                     int j = EntityXPOrb.getXPSplit(i);
                     i -= j;
-                    this.world.spawnEntity(new EntityXPOrb(this.world, this.posX, this.posY, this.posZ, j));
+                    //Craftbukkit start - add spawn reason and trigger entity
+                    //this.world.spawnEntity(new EntityXPOrb(this.world, this.posX, this.posY, this.posZ, j));
+                    this.world.spawnEntity(new EntityXPOrb(this.world, this.posX, this.posY, this.posZ, j, org.bukkit.entity.ExperienceOrb.SpawnReason.ENTITY_DEATH, this.attackingPlayer));
+                    //Craftbukkit end
                 }
-            }
+            this.expToDrop = 0; //Craftbukkit - TODO find out what is this
 
             this.setDead();
 
@@ -566,6 +606,17 @@
             }
         }
 
+        // CraftBukkit start
+        if (compound.hasKey("Bukkit.MaxHealth")){
+            net.minecraft.nbt.NBTBase nbtbase = compound.getTag("Bukkit.MaxHealth");
+            if (nbtbase.getId() == 5) {
+                this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(((net.minecraft.nbt.NBTTagFloat) nbtbase).getDouble());
+            } else if (nbtbase.getId() == 3) {
+                this.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(((net.minecraft.nbt.NBTTagInt) nbtbase).getDouble());
+            }
+        }
+        // CraftBukkit end
+
         if (compound.hasKey("Health", 99))
         {
             this.setHealth(compound.getFloat("Health"));
@@ -592,9 +643,15 @@
         }
     }
 
+    // CraftBukkit start
+    private boolean isTickingEffects = false;
+    private List<Object> effectsToProcess = com.google.common.collect.Lists.newArrayList();
+    // CraftBukkit end
+
     protected void updatePotionEffects()
     {
         Iterator<Potion> iterator = this.activePotionsMap.keySet().iterator();
+        isTickingEffects = true; // CraftBukkit
 
         try
         {
@@ -622,6 +679,18 @@
             ;
         }
 
+        // CraftBukkit start
+        isTickingEffects = false;
+        for (Object e : effectsToProcess) {
+            if (e instanceof PotionEffect) {
+                addPotionEffect((PotionEffect) e);
+            } else {
+                removePotionEffect((Potion) e);
+            }
+        }
+        effectsToProcess.clear();
+        // CraftBukkit end
+
         if (this.potionsNeedUpdate)
         {
             if (!this.world.isRemote)
@@ -740,6 +809,12 @@
 
     public void addPotionEffect(PotionEffect potioneffectIn)
     {
+        // CraftBukkit start
+        if (isTickingEffects) {
+            effectsToProcess.add(potioneffectIn);
+            return;
+        }
+        // CraftBukkit end
         if (this.isPotionApplicable(potioneffectIn))
         {
             PotionEffect potioneffect = this.activePotionsMap.get(potioneffectIn.getPotion());
@@ -784,6 +859,12 @@
     @Nullable
     public PotionEffect removeActivePotionEffect(@Nullable Potion potioneffectin)
     {
+        // CraftBukkit start
+        if (isTickingEffects) {
+            effectsToProcess.add(potioneffectin);
+            return null;
+        }
+        // CraftBukkit end
         return this.activePotionsMap.remove(potioneffectin);
     }
 
@@ -832,23 +913,67 @@
 
     public void heal(float healAmount)
     {
+        //Craftbukkit start ///Lava-test - TODO keep old one and make the CB one custom with external variable for spawn reason
+        /*healAmount = net.minecraftforge.event.ForgeEventFactory.onLivingHeal(this, healAmount);
+        if (healAmount <= 0) return;
+        float f = this.getHealth();
+        if (f > 0.0F)
+        {
+            this.setHealth(f + healAmount);
+        }*/
+        heal(healAmount, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.CUSTOM);
+        //Craftbukkit end
+    }
+
+    // CraftBukkit method - keep old one
+    public void heal(float healAmount, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason regainReason) {
         healAmount = net.minecraftforge.event.ForgeEventFactory.onLivingHeal(this, healAmount);
         if (healAmount <= 0) return;
         float f = this.getHealth();
 
         if (f > 0.0F)
         {
+            //Craftbukkit start
+            org.bukkit.event.entity.EntityRegainHealthEvent event = new org.bukkit.event.entity.EntityRegainHealthEvent(this.getBukkitEntity(), healAmount, regainReason);
+            this.world.getServer().getPluginManager().callEvent(event);
+
+            if (event.isCancelled()) {
+                return;
+            }
+            healAmount = (float) event.getAmount();
+            //Craftbukkit end
             this.setHealth(f + healAmount);
         }
     }
 
     public final float getHealth()
     {
+        // CraftBukkit start - Use unscaled health
+        if (this instanceof EntityPlayer) {
+            return (float) ((EntityPlayer) this).getBukkitEntity().getHealth();
+        }
+        // CraftBukkit end
         return ((Float)this.dataManager.get(HEALTH)).floatValue();
     }
 
     public void setHealth(float health)
     {
+        // CraftBukkit start - Handle scaled health
+        if (this instanceof EntityPlayer) {
+            org.bukkit.craftbukkit.entity.CraftPlayer player = ((EntityPlayerMP) this).getBukkitEntity();
+            // Squeeze
+            if (health < 0.0F) {
+                player.setRealHealth(0.0D);
+            } else if (health > player.getMaxHealth()) {
+                player.setRealHealth(player.getMaxHealth());
+            } else {
+                player.setRealHealth(health);
+            }
+
+            player.updateScaledHealth();
+            return;
+        }
+        // CraftBukkit end
         this.dataManager.set(HEALTH, Float.valueOf(MathHelper.clamp(health, 0.0F, this.getMaxHealth())));
     }
 
@@ -879,15 +1004,17 @@
             {
                 float f = amount;
 
-                if ((source == DamageSource.ANVIL || source == DamageSource.FALLING_BLOCK) && !this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).isEmpty())
+                // CraftBukkit - Moved into damageEntity_CB(DamageSource, float) ///Lava-test - completely rework damaging event and stuff, this is complete mess TODO
+                /*if ((source == DamageSource.ANVIL || source == DamageSource.FALLING_BLOCK) && !this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).isEmpty())
                 {
                     this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).damageItem((int)(amount * 4.0F + this.rand.nextFloat() * amount * 2.0F), this);
                     amount *= 0.75F;
-                }
+                }*/
 
-                boolean flag = false;
+                boolean flag = /*false*/amount > 0.0F && this.canBlockDamageSource(source); //Craftbukkit - Copied from below
 
-                if (amount > 0.0F && this.canBlockDamageSource(source))
+                // CraftBukkit - Moved into damageEntity0(DamageSource, float)
+                /*if (amount > 0.0F && this.canBlockDamageSource(source))
                 {
                     this.damageShield(amount);
                     amount = 0.0F;
@@ -903,7 +1030,7 @@
                     }
 
                     flag = true;
-                }
+                }*/
 
                 this.limbSwingAmount = 1.5F;
                 boolean flag1 = true;
@@ -912,18 +1039,29 @@
                 {
                     if (amount <= this.lastDamage)
                     {
+                        this.forceExplosionKnockback = true; // CraftBukkit - SPIGOT-949 - for vanilla consistency, cooldown does not prevent explosion knockback
                         return false;
                     }
 
-                    this.damageEntity(source, amount - this.lastDamage);
+                    // CraftBukkit start
+                    //this.damageEntity(source, amount - this.lastDamage);
+                    if (!this.damageEntity_CB(source, amount - this.lastDamage)) {
+                        return false;
+                    }
+                    // CraftBukkit end
                     this.lastDamage = amount;
                     flag1 = false;
                 }
                 else
                 {
+                    // CraftBukkit start
+                    if (!this.damageEntity_CB(source, amount)) {
+                        return false;
+                    }
+                    // CraftBukkit end
                     this.lastDamage = amount;
                     this.hurtResistantTime = this.maxHurtResistantTime;
-                    this.damageEntity(source, amount);
+                    //this.damageEntity(source, amount - this.lastDamage); //Craftbukkit
                     this.maxHurtTime = 10;
                     this.hurtTime = this.maxHurtTime;
                 }
@@ -1065,6 +1203,7 @@
         else
         {
             ItemStack itemstack = null;
+            org.bukkit.event.entity.EntityResurrectEvent event = new org.bukkit.event.entity.EntityResurrectEvent((org.bukkit.entity.LivingEntity) this.getBukkitEntity()); //Lava-test
 
             for (EnumHand enumhand : EnumHand.values())
             {
@@ -1073,14 +1212,26 @@
                 if (itemstack1.getItem() == Items.TOTEM_OF_UNDYING)
                 {
                     itemstack = itemstack1.copy();
+                    //Lava-test - handle event logic in case of holding the totem here TODO add one-liner call to LavaEventFactory
+                    event.setCancelled(false);
+                    this.world.getServer().getPluginManager().callEvent(event);
+                    if (event.isCancelled()) return false; //if the event is cancelled, don't revive and return false
+                    //Lava-test end
                     itemstack1.shrink(1);
                     break;
                 }
             }
 
+            //Lava-test start - the player don't have totem, call event as cancelled
+            if (itemstack == null) {
+                event.setCancelled(true);
+                this.world.getServer().getPluginManager().callEvent(event);
+                if (!event.isCancelled()) itemstack = new ItemStack(Items.APPLE); //if some plugin uncancel the event of resurrection, set the itemstack to *something* to pass the condition below
+            }
+            //lava-test  end
             if (itemstack != null)
             {
-                if (this instanceof EntityPlayerMP)
+                if (this instanceof EntityPlayerMP && itemstack.getItem() == Items.TOTEM_OF_UNDYING) //Lava-test - only increase stats if we actually held the totem
                 {
                     EntityPlayerMP entityplayermp = (EntityPlayerMP)this;
                     entityplayermp.addStat(StatList.getObjectUseStats(Items.TOTEM_OF_UNDYING));
@@ -1201,6 +1352,20 @@
 
                 if (!net.minecraftforge.common.ForgeHooks.onLivingDrops(this, cause, capturedDrops, i, recentlyHit > 0))
                 {
+                    // Lava start - first allow forge to alter drops, then plugins and finally spawn items
+                    if (capturedDrops.size() > 0) {
+                        this.drops = new java.util.ArrayList<>();
+                        // Lava - don't use forceDrops
+                        for (EntityItem item : capturedDrops) {
+                            this.drops.add(org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(item.getItem()));
+                        }
+
+                        org.bukkit.craftbukkit.event.CraftEventFactory.callEntityDeathEvent(this, this.drops); //TODO don't call death event here, it's not how it works!!! shame on me
+                    } else {
+                        org.bukkit.craftbukkit.event.CraftEventFactory.callEntityDeathEvent(this);
+                        // Lava end
+                    }
+
                     for (EntityItem item : capturedDrops)
                     {
                         world.spawnEntity(item);
@@ -1321,8 +1486,13 @@
 
         if (i > 0)
         {
+            // CraftBukkit start ///Lava-test - TODO move to forge?
+            if (!this.attackEntityFrom(DamageSource.FALL, (float) i)) {
+                return;
+            }
+            // CraftBukkit end
             this.playSound(this.getFallSound(i), 1.0F, 1.0F);
-            this.attackEntityFrom(DamageSource.FALL, (float)i);
+//            this.attackEntityFrom(DamageSource.FALL, (float)i); // CraftBukkit - moved up
             int j = MathHelper.floor(this.posX);
             int k = MathHelper.floor(this.posY - 0.20000000298023224D);
             int l = MathHelper.floor(this.posZ);
@@ -1362,7 +1532,7 @@
     {
         if (!source.isUnblockable())
         {
-            this.damageArmor(damage);
+//            this.damageArmor(damage); // CraftBukkit - Moved into damageEntity0(DamageSource, float)
             damage = CombatRules.getDamageAfterAbsorb(damage, (float)this.getTotalArmorValue(), (float)this.getEntityAttribute(SharedMonsterAttributes.ARMOR_TOUGHNESS).getAttributeValue());
         }
 
@@ -1377,13 +1547,14 @@
         }
         else
         {
-            if (this.isPotionActive(MobEffects.RESISTANCE) && source != DamageSource.OUT_OF_WORLD)
+            // CraftBukkit - Moved to damageEntity0(DamageSource, float)
+            /*if (this.isPotionActive(MobEffects.RESISTANCE) && source != DamageSource.OUT_OF_WORLD)
             {
                 int i = (this.getActivePotionEffect(MobEffects.RESISTANCE).getAmplifier() + 1) * 5;
                 int j = 25 - i;
                 float f = damage * (float)j;
                 damage = f / 25.0F;
-            }
+            }*/
 
             if (damage <= 0.0F)
             {
@@ -1403,8 +1574,11 @@
         }
     }
 
+    //Craftbukkit start - damage stuff TODO completely rework
     protected void damageEntity(DamageSource damageSrc, float damageAmount)
     {
+        this.damageEntity_CB(damageSrc, damageAmount);
+        /*
         if (!this.isEntityInvulnerable(damageSrc))
         {
             damageAmount = net.minecraftforge.common.ForgeHooks.onLivingHurt(this, damageSrc, damageAmount);
@@ -1424,8 +1598,146 @@
                 this.setAbsorptionAmount(this.getAbsorptionAmount() - damageAmount);
             }
         }
+         */
     }
 
+    protected boolean damageEntity_CB(final DamageSource damagesource, float f) { // void -> boolean, add final
+        if (!this.isEntityInvulnerable(damagesource)) {
+            final boolean human = this instanceof EntityPlayer;
+            float originalDamage = f;
+            com.google.common.base.Function<Double, Double> hardHat = new com.google.common.base.Function<Double, Double>() {
+                @Override
+                public Double apply(Double f) {
+                    if ((damagesource == DamageSource.ANVIL || damagesource == DamageSource.FALLING_BLOCK) && !EntityLivingBase.this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).isEmpty()) {
+                        return -(f - (f * 0.75F));
+
+                    }
+                    return -0.0;
+                }
+            };
+            float hardHatModifier = hardHat.apply((double) f).floatValue();
+            f += hardHatModifier;
+
+            com.google.common.base.Function<Double, Double> blocking = new com.google.common.base.Function<Double, Double>() {
+                @Override
+                public Double apply(Double f) {
+                    return -((EntityLivingBase.this.canBlockDamageSource(damagesource)) ? f : 0.0);
+                }
+            };
+            float blockingModifier = blocking.apply((double) f).floatValue();
+            f += blockingModifier;
+
+            com.google.common.base.Function<Double, Double> armor = new com.google.common.base.Function<Double, Double>() {
+                @Override
+                public Double apply(Double f) {
+                    return -(f - EntityLivingBase.this.applyArmorCalculations(damagesource, f.floatValue()));
+                }
+            };
+            float armorModifier = armor.apply((double) f).floatValue();
+            f += armorModifier;
+
+            com.google.common.base.Function<Double, Double> resistance = new com.google.common.base.Function<Double, Double>() {
+                @Override
+                public Double apply(Double f) {
+                    if (!damagesource.isDamageAbsolute() && EntityLivingBase.this.isPotionActive(MobEffects.RESISTANCE) && damagesource != DamageSource.OUT_OF_WORLD) {
+                        int i = (EntityLivingBase.this.getActivePotionEffect(MobEffects.RESISTANCE).getAmplifier() + 1) * 5;
+                        int j = 25 - i;
+                        float f1 = f.floatValue() * (float) j;
+                        return -(f - (f1 / 25.0F));
+                    }
+                    return -0.0;
+                }
+            };
+            float resistanceModifier = resistance.apply((double) f).floatValue();
+            f += resistanceModifier;
+
+            com.google.common.base.Function<Double, Double> magic = new com.google.common.base.Function<Double, Double>() {
+                @Override
+                public Double apply(Double f) {
+                    return -(f - EntityLivingBase.this.applyPotionDamageCalculations(damagesource, f.floatValue()));
+                }
+            };
+            float magicModifier = magic.apply((double) f).floatValue();
+            f += magicModifier;
+
+            com.google.common.base.Function<Double, Double> absorption = new com.google.common.base.Function<Double, Double>() {
+                @Override
+                public Double apply(Double f) {
+                    return -(Math.max(f - Math.max(f - EntityLivingBase.this.getAbsorptionAmount(), 0.0F), 0.0F));
+                }
+            };
+            float absorptionModifier = absorption.apply((double) f).floatValue();
+
+            org.bukkit.event.entity.EntityDamageEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.handleLivingEntityDamageEvent(this, damagesource, originalDamage, hardHatModifier, blockingModifier, armorModifier, resistanceModifier, magicModifier, absorptionModifier, hardHat, blocking, armor, resistance, magic, absorption);
+            if (event.isCancelled()) {
+                return false;
+            }
+
+            f = (float) event.getFinalDamage();
+
+            // Apply damage to helmet
+            if ((damagesource == DamageSource.ANVIL || damagesource == DamageSource.FALLING_BLOCK) && this.getItemStackFromSlot(EntityEquipmentSlot.HEAD) != null) {
+                this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).damageItem((int) (event.getDamage() * 4.0F + this.rand.nextFloat() * event.getDamage() * 2.0F), this);
+            }
+
+            // Apply damage to armor
+            if (!damagesource.isUnblockable()) {
+                float armorDamage = (float) (event.getDamage() + event.getDamage(org.bukkit.event.entity.EntityDamageEvent.DamageModifier.BLOCKING) + event.getDamage(org.bukkit.event.entity.EntityDamageEvent.DamageModifier.HARD_HAT));
+                this.damageArmor(armorDamage);
+            }
+
+            // Apply blocking code // PAIL: steal from above
+            if (event.getDamage(org.bukkit.event.entity.EntityDamageEvent.DamageModifier.BLOCKING) < 0) {
+                this.damageShield((float) -event.getDamage(org.bukkit.event.entity.EntityDamageEvent.DamageModifier.BLOCKING));
+                Entity entity = damagesource.getImmediateSource();
+
+                if (entity instanceof EntityLivingBase) {
+                    this.blockUsingShield((EntityLivingBase) entity);
+                }
+            }
+
+            absorptionModifier = (float) -event.getDamage(org.bukkit.event.entity.EntityDamageEvent.DamageModifier.ABSORPTION);
+            this.setAbsorptionAmount(Math.max(this.getAbsorptionAmount() - absorptionModifier, 0.0F));
+            if (f > 0 || !human) {
+                if (human) {
+                    // PAIL: Be sure to drag all this code from the EntityPlayer subclass each update.
+                    ((EntityPlayer) this).addExhaustion(damagesource.getHungerDamage());
+                    if (f < 3.4028235E37F) {
+                        ((EntityPlayer) this).addStat(StatList.DAMAGE_TAKEN, Math.round(f * 10.0F));
+                    }
+                }
+                // CraftBukkit end
+                float f2 = this.getHealth();
+
+                this.setHealth(f2 - f);
+                this.getCombatTracker().trackDamage(damagesource, f2, f);
+                // CraftBukkit start
+                if (!human) {
+                    this.setAbsorptionAmount(this.getAbsorptionAmount() - f);
+                }
+
+                return true;
+            } else {
+                // Duplicate triggers if blocking
+                if (event.getDamage(org.bukkit.event.entity.EntityDamageEvent.DamageModifier.BLOCKING) < 0) {
+                    if (this instanceof EntityPlayerMP) {
+                        CriteriaTriggers.ENTITY_HURT_PLAYER.trigger((EntityPlayerMP) this, damagesource, f, originalDamage, true);
+                    }
+
+                    if (damagesource.getTrueSource() instanceof EntityPlayerMP) {
+                        CriteriaTriggers.PLAYER_HURT_ENTITY.trigger((EntityPlayerMP) damagesource.getTrueSource(), this, damagesource, f, originalDamage, true);
+                    }
+
+                    return false;
+                } else {
+                    return originalDamage > 0;
+                }
+                // CraftBukkit end
+            }
+        }
+        return false; // CraftBukkit end
+    }
+
     public CombatTracker getCombatTracker()
     {
         return this._combatTracker;
@@ -1605,6 +1917,7 @@
         if (this.attributeMap == null)
         {
             this.attributeMap = new AttributeMap();
+            this.craftAttributes = new org.bukkit.craftbukkit.attribute.CraftAttributeMap(attributeMap); // CraftBukkit
         }
 
         return this.attributeMap;
@@ -1900,6 +2213,7 @@
 
                         if (this.onGround && !this.world.isRemote)
                         {
+                            if (getFlag(7) && !org.bukkit.craftbukkit.event.CraftEventFactory.callToggleGlideEvent(this, false).isCancelled()) //Craftbukkit
                             this.setFlag(7, false);
                         }
                     }
@@ -2426,6 +2740,7 @@
 
         if (!this.world.isRemote)
         {
+            if (flag != this.getFlag(7) && !org.bukkit.craftbukkit.event.CraftEventFactory.callToggleGlideEvent(this, flag).isCancelled()) // CraftBukkit
             this.setFlag(7, flag);
         }
     }
@@ -2560,12 +2875,12 @@
 
     public boolean canBeCollidedWith()
     {
-        return !this.isDead;
+        return !this.dead && this.collides; // CraftBukkit - added "&& this.collides" to disable collision on demand
     }
 
     public boolean canBePushed()
     {
-        return this.isEntityAlive() && !this.isOnLadder();
+        return this.isEntityAlive() && !this.isOnLadder() && this.collides; // CraftBukkit - added "&& this.collides" to disable collision
     }
 
     protected void markVelocityChanged()
@@ -2786,7 +3101,26 @@
         {
             this.updateItemUse(this.activeItemStack, 16);
             ItemStack activeItemStackCopy = this.activeItemStack.copy();
+            //Lava-test start - fire event
+            if (this instanceof EntityPlayer) {
+                org.bukkit.inventory.ItemStack craftItem = org.bukkit.craftbukkit.inventory.CraftItemStack.asBukkitCopy(this.activeItemStack);
+                org.bukkit.event.player.PlayerItemConsumeEvent event = new org.bukkit.event.player.PlayerItemConsumeEvent((org.bukkit.entity.Player) this.getBukkitEntity(), craftItem);
+                world.getServer().getPluginManager().callEvent(event);
+
+                if (event.isCancelled()) {
+                    // Update client - TODO is this needed?
+                    ((EntityPlayerMP) this).getBukkitEntity().updateInventory();
+                    ((EntityPlayerMP) this).getBukkitEntity().updateScaledHealth();
+                    return;
+                }
+
+                if (!(craftItem.equals(event.getItem()))) {
+                    this.activeItemStack = org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(event.getItem()); //set activeItemStack to event item so we don't have to modify code below
+                }
+            }
+            //Lava-test end
             ItemStack itemstack = this.activeItemStack.onItemUseFinish(this.world, this);
+            this.activeItemStack = activeItemStackCopy; //Lava-test - revert back, just in case
             itemstack = net.minecraftforge.event.ForgeEventFactory.onItemUseFinish(this, activeItemStackCopy, getItemInUseCount(), itemstack);
             this.setHeldItem(this.getActiveHand(), itemstack);
             this.resetActiveHand();
@@ -2897,12 +3231,20 @@
 
             if (flag1)
             {
-                this.setPositionAndUpdate(this.posX, this.posY, this.posZ);
+                // CraftBukkit start - Teleport event
+                //this.setPositionAndUpdate(this.posX, this.posY, this.posZ);
+                org.bukkit.event.entity.EntityTeleportEvent teleport = new org.bukkit.event.entity.EntityTeleportEvent(this.getBukkitEntity(), new org.bukkit.Location(this.world.getWorld(), d0, d1, d2), new org.bukkit.Location(this.world.getWorld(), this.posX, this.posY, this.posZ));
+                this.world.getServer().getPluginManager().callEvent(teleport);
 
+                if (!teleport.isCancelled()) {
+                    org.bukkit.Location to = teleport.getTo();
+                    this.setPositionAndUpdate(to.getX(), to.getY(), to.getZ());
+                //Craftbukkit end
                 if (world.getCollisionBoxes(this, this.getEntityBoundingBox()).isEmpty() && !world.containsAnyLiquid(this.getEntityBoundingBox()))
                 {
                     flag = true;
                 }
+                }
             }
         }
 
@@ -2936,6 +3278,13 @@
         }
     }
 
+    //Craftbukkit method
+    @Override
+    public float getBukkitYaw()
+    {
+        return getRotationYawHead();
+    }
+
     public boolean canBeHitWithPotion()
     {
         return true;
