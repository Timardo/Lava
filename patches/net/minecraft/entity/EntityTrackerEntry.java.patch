--- ../src-base/minecraft/net/minecraft/entity/EntityTrackerEntry.java
+++ ../src-work/minecraft/net/minecraft/entity/EntityTrackerEntry.java
@@ -148,15 +148,18 @@
         if (!list.equals(this.passengers))
         {
             this.passengers = list;
-            this.sendPacketToTrackedPlayers(new SPacketSetPassengers(this.trackedEntity));
+            //Craftbukkit start - ???
+            //this.sendPacketToTrackedPlayers(new SPacketSetPassengers(this.trackedEntity));
+            this.sendToTrackingAndSelf(new SPacketSetPassengers(this.trackedEntity));
+            //Craftbukkit end
         }
 
-        if (this.trackedEntity instanceof EntityItemFrame && this.updateCounter % 10 == 0)
+        if (this.trackedEntity instanceof EntityItemFrame /*&& this.updateCounter % 10 == 0*/) // CraftBukkit - Moved below, should always enter this block
         {
             EntityItemFrame entityitemframe = (EntityItemFrame)this.trackedEntity;
             ItemStack itemstack = entityitemframe.getDisplayedItem();
 
-            if (itemstack.getItem() instanceof ItemMap)
+            if (this.updateCounter % 10 == 0 && itemstack.getItem() instanceof ItemMap)// CraftBukkit - Moved this.updateCounter % 10 logic here so item frames do not enter the other blocks
             {
                 MapData mapdata = ((ItemMap) itemstack.getItem()).getMapData(itemstack, this.trackedEntity.world);
 
@@ -236,6 +239,11 @@
                     {
                         this.onGround = this.trackedEntity.onGround;
                         this.ticksSinceLastForcedTeleport = 0;
+                        // CraftBukkit start - Refresh list of who can see a player before sending teleport packet
+                        if (this.trackedEntity instanceof EntityPlayer) {
+                            this.updatePlayerEntities(new java.util.ArrayList<>(this.trackingPlayers));
+                        }
+                        // CraftBukkit end
                         this.resetPlayerVisibility();
                         packet1 = new SPacketEntityTeleport(this.trackedEntity);
                     }
@@ -303,6 +311,25 @@
 
         if (this.trackedEntity.velocityChanged)
         {
+            // CraftBukkit start - Create PlayerVelocity event
+            boolean cancelled = false;
+
+            if (this.trackedEntity instanceof EntityPlayer) {
+                org.bukkit.entity.Player player = (org.bukkit.entity.Player) this.trackedEntity.getBukkitEntity();
+                org.bukkit.util.Vector velocity = player.getVelocity();
+
+                org.bukkit.event.player.PlayerVelocityEvent event = new org.bukkit.event.player.PlayerVelocityEvent(player, velocity.clone());
+                this.trackedEntity.world.getServer().getPluginManager().callEvent(event);
+
+                if (event.isCancelled()) {
+                    cancelled = true;
+                } else if (!velocity.equals(event.getVelocity())) {
+                    player.setVelocity(event.getVelocity());
+                }
+            }
+
+            if (!cancelled)
+            // CraftBukkit end
             this.sendToTrackingAndSelf(new SPacketEntityVelocity(this.trackedEntity));
             this.trackedEntity.velocityChanged = false;
         }
@@ -324,6 +351,11 @@
 
             if (!set.isEmpty())
             {
+                // CraftBukkit start - Send scaled max health
+                if (this.trackedEntity instanceof EntityPlayerMP) {
+                    ((EntityPlayerMP) this.trackedEntity).getBukkitEntity().injectScaledMaxHealth(set, false);
+                }
+                // CraftBukkit end
                 this.sendToTrackingAndSelf(new SPacketEntityProperties(this.trackedEntity.getEntityId(), set));
             }
 
@@ -376,6 +408,16 @@
             {
                 if (!this.trackingPlayers.contains(playerMP) && (this.isPlayerWatchingThisChunk(playerMP) || this.trackedEntity.forceSpawn))
                 {
+                    // CraftBukkit start - respect vanish API
+                    if (this.trackedEntity instanceof EntityPlayerMP) {
+                        org.bukkit.entity.Player player = ((EntityPlayerMP) this.trackedEntity).getBukkitEntity();
+                        if (!playerMP.getBukkitEntity().canSee(player)) {
+                            return;
+                        }
+                    }
+
+                    playerMP.entityRemoveQueue.remove(Integer.valueOf(this.trackedEntity.getEntityId()));
+                    // CraftBukkit end
                     this.trackingPlayers.add(playerMP);
                     Packet<?> packet = this.createSpawnPacket();
                     playerMP.connection.sendPacket(packet);
@@ -392,6 +434,13 @@
                         AttributeMap attributemap = (AttributeMap)((EntityLivingBase)this.trackedEntity).getAttributeMap();
                         Collection<IAttributeInstance> collection = attributemap.getWatchedAttributes();
 
+                        // CraftBukkit start - If sending own attributes send scaled health instead of current maximum health
+                        if (this.trackedEntity.getEntityId() == playerMP.getEntityId()) {
+                            // TODO: Maybe we should check for instanceof before casting to EntityPlayerMP?
+                            ((EntityPlayerMP) this.trackedEntity).getBukkitEntity().injectScaledMaxHealth(collection, false);
+                        }
+                        // CraftBukkit end
+
                         if (!collection.isEmpty())
                         {
                             playerMP.connection.sendPacket(new SPacketEntityProperties(this.trackedEntity.getEntityId(), collection));
@@ -435,6 +484,11 @@
                         }
                     }
 
+                    // CraftBukkit start - Fix for nonsensical head yaw
+                    this.lastHeadMotion = MathHelper.floor(this.trackedEntity.getRotationYawHead() * 256.0F / 360.0F);
+                    this.sendPacketToTrackedPlayers(new SPacketEntityHeadLook(this.trackedEntity, (byte) lastHeadMotion));
+                    // CraftBukkit end
+
                     if (this.trackedEntity instanceof EntityLivingBase)
                     {
                         EntityLivingBase entitylivingbase = (EntityLivingBase)this.trackedEntity;
