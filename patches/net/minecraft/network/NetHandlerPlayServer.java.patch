--- ../src-base/minecraft/net/minecraft/network/NetHandlerPlayServer.java
+++ ../src-work/minecraft/net/minecraft/network/NetHandlerPlayServer.java
@@ -131,7 +131,9 @@
     private long field_194402_f;
     private boolean field_194403_g;
     private long field_194404_h;
+    /* CraftBukkit - multithreaded fields
     private int chatSpamThresholdCount;
+    */
     private int itemDropThreshold;
     private final IntHashMap<Short> pendingTransactions = new IntHashMap<Short>();
     private double firstGoodX;
@@ -165,6 +167,7 @@
         networkManagerIn.setNetHandler(this);
         this.player = playerIn;
         playerIn.connection = this;
+        this.server = this.serverController.server; //Craftbukkit
     }
 
     public void update()
@@ -226,7 +229,7 @@
         this.serverController.profiler.startSection("keepAlive");
         long i = this.currentTimeMillis();
 
-        if (i - this.field_194402_f >= 15000L)
+        if (i - this.field_194402_f >= 25000L) // CraftBukkit - 15000L -> 25000L - prolonging the timeout time
         {
             if (this.field_194403_g)
             {
@@ -242,11 +245,15 @@
         }
 
         this.serverController.profiler.endSection();
+        // CraftBukkit start
+        for (int spam; (spam = this.chatThrottle) > 0 && !chatSpamField.compareAndSet(this, spam, spam - 1); ) ;
+        /* Use thread-safe field access instead
 
         if (this.chatSpamThresholdCount > 0)
         {
             --this.chatSpamThresholdCount;
         }
+        // CraftBukkit end */
 
         if (this.itemDropThreshold > 0)
         {
@@ -255,11 +262,12 @@
 
         if (this.player.getLastActiveTime() > 0L && this.serverController.getMaxPlayerIdleMinutes() > 0 && MinecraftServer.getCurrentTimeMillis() - this.player.getLastActiveTime() > (long)(this.serverController.getMaxPlayerIdleMinutes() * 1000 * 60))
         {
+            this.player.markPlayerActive(); // CraftBukkit - SPIGOT-854
             this.disconnect(new TextComponentTranslation("multiplayer.disconnect.idling", new Object[0]));
         }
     }
 
-    private void captureCurrentPosition()
+    public void captureCurrentPosition() //Craftbukkit - private -> public
     {
         this.firstGoodX = this.player.posX;
         this.firstGoodY = this.player.posY;
@@ -276,11 +284,18 @@
 
     public void disconnect(final ITextComponent textComponent)
     {
-        this.netManager.sendPacket(new SPacketDisconnect(textComponent), new GenericFutureListener < Future <? super Void >> ()
+        //Lava-test start - fire PlayerKickEvent
+        if (this.processedDisconnect) return;
+        org.bukkit.event.player.PlayerKickEvent event = new org.bukkit.event.player.PlayerKickEvent(this.server.getPlayer(this.player), org.bukkit.craftbukkit.util.CraftChatMessage.fromComponent(textComponent, TextFormatting.WHITE), TextFormatting.YELLOW + this.player.getName() + " left the game.");
+        if (this.server.getServer().isServerRunning()) this.server.getPluginManager().callEvent(event);
+        if (event.isCancelled()) return;
+        final ITextComponent textComponentVar = new TextComponentTranslation(event.getReason());
+        //Lava-test end (don not add the rest of patches in this method, TODO check if it causes issues)
+        this.netManager.sendPacket(new SPacketDisconnect(textComponentVar), new GenericFutureListener < Future <? super Void >> () //Lava-test - textComponent -> textComponentVar
         {
             public void operationComplete(Future <? super Void > p_operationComplete_1_) throws Exception
             {
-                NetHandlerPlayServer.this.netManager.closeChannel(textComponent);
+                NetHandlerPlayServer.this.netManager.closeChannel(textComponentVar); //Lava-test - textComponent -> textComponentVar
             }
         });
         this.netManager.disableAutoRead();
@@ -345,8 +360,32 @@
                 double d9 = entity.motionX * entity.motionX + entity.motionY * entity.motionY + entity.motionZ * entity.motionZ;
                 double d10 = d6 * d6 + d7 * d7 + d8 * d8;
 
+                /* CraftBukkit start - handle custom speeds and skipped ticks
                 if (d10 - d9 > 100.0D && (!this.serverController.isSinglePlayer() || !this.serverController.getServerOwner().equals(entity.getName())))
                 {
+                */
+                float speed;
+                this.allowedPlayerTicks += (System.currentTimeMillis() / 50) - this.lastTick;
+                this.allowedPlayerTicks = Math.max(this.allowedPlayerTicks, 1);
+                this.lastTick = (int) (System.currentTimeMillis() / 50);
+                ++this.movePacketCounter;
+                int i = this.movePacketCounter - this.lastMovePacketCounter;
+                
+                if (i > Math.max(this.allowedPlayerTicks, 5)) {
+                    NetHandlerPlayServer.LOGGER.debug(this.player.getName() + " is sending move packets too frequently (" + i + " packets since last tick)");
+                    i = 1;
+                }
+                
+                if (d10 > 0) allowedPlayerTicks -= 1;
+                else allowedPlayerTicks = 20;
+
+                if (player.capabilities.isFlying) speed = player.capabilities.flySpeed * 20f;
+                else speed = player.capabilities.walkSpeed * 10f;
+                
+                speed *= 2f; // TODO: Get the speed of the vehicle instead of the player
+
+                if (d10 - d9 > Math.max(100.0D, Math.pow((double) (10.0F * (float) i * speed), 2)) && (!this.serverController.isSinglePlayer() || !this.serverController.getServerOwner().equals(entity.getName()))) {
+                    // CraftBukkit end
                     LOGGER.warn("{} (vehicle of {}) moved too quickly! {},{},{}", entity.getName(), this.player.getName(), Double.valueOf(d6), Double.valueOf(d7), Double.valueOf(d8));
                     this.netManager.sendPacket(new SPacketMoveVehicle(entity));
                     return;
@@ -388,6 +427,62 @@
                     return;
                 }
 
+                // CraftBukkit start - fire PlayerMoveEvent TODO move to LavEventFactory with less var declaraion
+                org.bukkit.entity.Player player = this.getPlayer();
+                org.bukkit.Location from = new org.bukkit.Location(player.getWorld(), lastPosX, lastPosY, lastPosZ, lastYaw, lastPitch); // Get the Players previous Event location.
+                org.bukkit.Location to = player.getLocation().clone(); // Start off the To location as the Players current location.
+
+                // If the packet contains movement information then we update the To location with the correct XYZ.
+                to.setX(packetIn.getX());
+                to.setY(packetIn.getY());
+                to.setZ(packetIn.getZ());
+
+
+                // If the packet contains look information then we update the To location with the correct Yaw & Pitch.
+                to.setYaw(packetIn.getYaw());
+                to.setPitch(packetIn.getPitch());
+
+                // Prevent 40 event-calls for less than a single pixel of movement >.>
+                double delta = Math.pow(this.lastPosX - to.getX(), 2) + Math.pow(this.lastPosY - to.getY(), 2) + Math.pow(this.lastPosZ - to.getZ(), 2);
+                float deltaAngle = Math.abs(this.lastYaw - to.getYaw()) + Math.abs(this.lastPitch - to.getPitch());
+
+                if ((delta > 1f / 256 || deltaAngle > 10f) && !this.player.isMovementBlocked()) {
+                    this.lastPosX = to.getX();
+                    this.lastPosY = to.getY();
+                    this.lastPosZ = to.getZ();
+                    this.lastYaw = to.getYaw();
+                    this.lastPitch = to.getPitch();
+
+                    // Skip the first time we do this
+                    if (from.getX() != Double.MAX_VALUE) {
+                        org.bukkit.Location oldTo = to.clone();
+                        org.bukkit.event.player.PlayerMoveEvent event = new org.bukkit.event.player.PlayerMoveEvent(player, from, to);
+                        this.server.getPluginManager().callEvent(event);
+
+                        // If the event is cancelled we move the player back to their old location.
+                        if (event.isCancelled()) {
+                            teleport(from);
+                            return;
+                        }
+
+                        // If a Plugin has changed the To destination then we teleport the Player
+                        // there to avoid any 'Moved wrongly' or 'Moved too quickly' errors.
+                        // We only do this if the Event was not cancelled.
+                        if (!oldTo.equals(event.getTo()) && !event.isCancelled()) {
+                            this.player.getBukkitEntity().teleport(event.getTo(), org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.PLUGIN);
+                            return;
+                        }
+
+                        // Check to see if the Players Location has some how changed during the call of the event.
+                        // This can happen due to a plugin teleporting the player instead of using .setTo()
+                        if (!from.equals(this.getPlayer().getLocation()) && this.justTeleported) {
+                            this.justTeleported = false;
+                            return;
+                        }
+                    }
+                }
+                // CraftBukkit end
+
                 this.serverController.getPlayerList().serverUpdateMovingPlayer(this.player);
                 this.player.addMovementStat(this.player.posX - d0, this.player.posY - d1, this.player.posZ - d2);
                 this.vehicleFloating = d11 >= -0.03125D && !this.serverController.isFlightAllowed() && !worldserver.checkBlockCollision(entity.getEntityBoundingBox().grow(0.0625D).expand(0.0D, -0.55D, 0.0D));
@@ -402,7 +497,7 @@
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
 
-        if (packetIn.getTeleportId() == this.teleportId)
+        if (packetIn.getTeleportId() == this.teleportId /*Craftbukkit - add null check*/ && this.targetPos != null)
         {
             this.player.setPositionAndRotation(this.targetPos.x, this.targetPos.y, this.targetPos.z, this.player.rotationYaw, this.player.rotationPitch);
 
@@ -461,7 +556,7 @@
         {
             WorldServer worldserver = this.serverController.getWorld(this.player.dimension);
 
-            if (!this.player.queuedEndExit)
+            if (!this.player.queuedEndExit /*Craftbukkit - add check*/ && !this.player.isMovementBlocked())
             {
                 if (this.networkTickCount == 0)
                 {
@@ -475,6 +570,7 @@
                         this.lastPositionUpdate = this.networkTickCount;
                         this.setPlayerLocation(this.targetPos.x, this.targetPos.y, this.targetPos.z, this.player.rotationYaw, this.player.rotationPitch);
                     }
+                    this.allowedPlayerTicks = 20; //Craftbukkit
                 }
                 else
                 {
@@ -484,9 +580,17 @@
                     {
                         this.player.setPositionAndRotation(this.player.posX, this.player.posY, this.player.posZ, packetIn.getYaw(this.player.rotationYaw), packetIn.getPitch(this.player.rotationPitch));
                         this.serverController.getPlayerList().serverUpdateMovingPlayer(this.player);
+                        this.allowedPlayerTicks = 20; //Craftbukkit 
                     }
                     else
                     {
+                        // CraftBukkit - Make sure the move is valid but then reset it for plugins to modify
+                        double prevX = player.posX;
+                        double prevY = player.posY;
+                        double prevZ = player.posZ;
+                        float prevYaw = player.rotationYaw;
+                        float prevPitch = player.rotationPitch;
+                        // CraftBukkit end
                         double d0 = this.player.posX;
                         double d1 = this.player.posY;
                         double d2 = this.player.posZ;
@@ -514,17 +618,36 @@
                             ++this.movePacketCounter;
                             int i = this.movePacketCounter - this.lastMovePacketCounter;
 
+                            // CraftBukkit start - handle custom speeds and skipped ticks
+                            float speed;
+                            this.allowedPlayerTicks += (System.currentTimeMillis() / 50) - this.lastTick;
+                            this.allowedPlayerTicks = Math.max(this.allowedPlayerTicks, 1);
+                            this.lastTick = (int) (System.currentTimeMillis() / 50);
+
+                            if (i > Math.max(this.allowedPlayerTicks, 5))
+                            /*
                             if (i > 5)
+                            */
+                            //Craftbukkit end
                             {
                                 LOGGER.debug("{} is sending move packets too frequently ({} packets since last tick)", this.player.getName(), Integer.valueOf(i));
                                 i = 1;
                             }
+                            //Craftbukkit start
+                            if (packetIn.rotating || d11 > 0) allowedPlayerTicks -= 1;
+                            else allowedPlayerTicks = 20;
+                            if (player.capabilities.isFlying) speed = player.capabilities.flySpeed * 20f;
+                            else speed = player.capabilities.walkSpeed * 10f;
+                            //Craftbukkit end
 
                             if (!this.player.isInvulnerableDimensionChange() && (!this.player.getServerWorld().getGameRules().getBoolean("disableElytraMovementCheck") || !this.player.isElytraFlying()))
                             {
                                 float f2 = this.player.isElytraFlying() ? 300.0F : 100.0F;
 
+                                /* Craftbukkit - ???
                                 if (d11 - d10 > (double)(f2 * (float)i) && (!this.serverController.isSinglePlayer() || !this.serverController.getServerOwner().equals(this.player.getName())))
+                                 */
+                                if (d11 - d10 > Math.max(f2, Math.pow((double)(10.0F * (float)i * speed), 2)) && (!this.serverController.isSinglePlayer() || !this.serverController.getServerOwner().equals(this.player.getName())))
                                 {
                                     LOGGER.warn("{} moved too quickly! {},{},{}", this.player.getName(), Double.valueOf(d7), Double.valueOf(d8), Double.valueOf(d9));
                                     this.setPlayerLocation(this.player.posX, this.player.posY, this.player.posZ, this.player.rotationYaw, this.player.rotationPitch);
@@ -577,6 +700,67 @@
                                 }
                             }
 
+                            // CraftBukkit start - fire PlayerMoveEvent
+                            // Rest to old location first
+                            this.player.setPositionAndRotation(prevX, prevY, prevZ, prevYaw, prevPitch);
+
+                            org.bukkit.entity.Player player = this.getPlayer();
+                            org.bukkit.Location from = new org.bukkit.Location(player.getWorld(), lastPosX, lastPosY, lastPosZ, lastYaw, lastPitch); // Get the Players previous Event location.
+                            org.bukkit.Location to = player.getLocation().clone(); // Start off the To location as the Players current location.
+
+                            // If the packet contains movement information then we update the To location with the correct XYZ.
+                            if (packetIn.moving) {
+                                to.setX(packetIn.x);
+                                to.setY(packetIn.y);
+                                to.setZ(packetIn.z);
+                            }
+                            // If the packet contains look information then we update the To location with the correct Yaw & Pitch.
+                            if (packetIn.rotating) {
+                                to.setYaw(packetIn.yaw);
+                                to.setPitch(packetIn.pitch);
+                            }
+                            // Prevent 40 event-calls for less than a single pixel of movement >.>
+                            double delta = Math.pow(this.lastPosX - to.getX(), 2) + Math.pow(this.lastPosY - to.getY(), 2) + Math.pow(this.lastPosZ - to.getZ(), 2);
+                            float deltaAngle = Math.abs(this.lastYaw - to.getYaw()) + Math.abs(this.lastPitch - to.getPitch());
+
+                            if ((delta > 1f / 256 || deltaAngle > 10f) && !this.player.isMovementBlocked()) {
+                                this.lastPosX = to.getX();
+                                this.lastPosY = to.getY();
+                                this.lastPosZ = to.getZ();
+                                this.lastYaw = to.getYaw();
+                                this.lastPitch = to.getPitch();
+
+                                // Skip the first time we do this
+                                if (from.getX() != Double.MAX_VALUE) {
+                                    org.bukkit.Location oldTo = to.clone();
+                                    org.bukkit.event.player.PlayerMoveEvent event = new org.bukkit.event.player.PlayerMoveEvent(player, from, to);
+                                    this.server.getPluginManager().callEvent(event);
+
+                                    // If the event is cancelled we move the player back to their old location.
+                                    if (event.isCancelled()) {
+                                        teleport(from);
+                                        return;
+                                    }
+
+                                    // If a Plugin has changed the To destination then we teleport the Player
+                                    // there to avoid any 'Moved wrongly' or 'Moved too quickly' errors.
+                                    // We only do this if the Event was not cancelled.
+                                    if (!oldTo.equals(event.getTo()) && !event.isCancelled()) {
+                                        this.player.getBukkitEntity().teleport(event.getTo(), org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.PLUGIN);
+                                        return;
+                                    }
+
+                                    // Check to see if the Players Location has some how changed during the call of the event.
+                                    // This can happen due to a plugin teleporting the player instead of using .setTo()
+                                    if (!from.equals(this.getPlayer().getLocation()) && this.justTeleported) {
+                                        this.justTeleported = false;
+                                        return;
+                                    }
+                                }
+                            }
+                            this.player.setPositionAndRotation(d4, d5, d6, f, f1); // Copied from above
+                            // CraftBukkit end
+
                             this.floating = d12 >= -0.03125D;
                             this.floating &= !this.serverController.isFlightAllowed() && !this.player.capabilities.allowFlying;
                             this.floating &= !this.player.isPotionActive(MobEffects.LEVITATION) && !this.player.isElytraFlying() && !worldserver.checkBlockCollision(this.player.getEntityBoundingBox().grow(0.0625D).expand(0.0D, -0.55D, 0.0D));
@@ -600,10 +784,24 @@
 
     public void setPlayerLocation(double x, double y, double z, float yaw, float pitch, Set<SPacketPlayerPosLook.EnumFlags> relativeSet)
     {
+        org.bukkit.entity.Player player = this.getPlayer();
+        org.bukkit.Location from = player.getLocation();
+        // CraftBukkit start
+        if (Float.isNaN(yaw)) {
+            yaw = 0;
+        }
+        if (Float.isNaN(pitch)) {
+            pitch = 0;
+        }
+
+        this.justTeleported = true;
+        // CraftBukkit end
         double d0 = relativeSet.contains(SPacketPlayerPosLook.EnumFlags.X) ? this.player.posX : 0.0D;
         double d1 = relativeSet.contains(SPacketPlayerPosLook.EnumFlags.Y) ? this.player.posY : 0.0D;
         double d2 = relativeSet.contains(SPacketPlayerPosLook.EnumFlags.Z) ? this.player.posZ : 0.0D;
+        /* Lava-test - move down
         this.targetPos = new Vec3d(x + d0, y + d1, z + d2);
+         */
         float f = yaw;
         float f1 = pitch;
 
@@ -616,7 +814,31 @@
         {
             f1 = pitch + this.player.rotationPitch;
         }
+        //Lava-test start - event TODO check teleporting stuff
+        org.bukkit.Location to = new org.bukkit.Location(this.getPlayer().getWorld(), d0, d1, d2, f, f1);
+        org.bukkit.event.player.PlayerTeleportEvent event = new org.bukkit.event.player.PlayerTeleportEvent(player, from.clone(), to.clone(), this.teleportCause == null ? org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.UNKNOWN : this.teleportCause);
+        this.teleportCause = null;
+        this.server.getPluginManager().callEvent(event);
 
+        if (event.isCancelled() || !to.equals(event.getTo())) {
+            relativeSet.clear(); // Can't relative teleport
+            to = event.isCancelled() ? event.getFrom() : event.getTo();
+            x = to.getX();
+            y = to.getY();
+            z = to.getZ();
+            yaw = to.getYaw();
+            pitch = to.getPitch();
+        }
+        
+        this.targetPos = new Vec3d(x + d0, y + d1, z + d2);
+        // CraftBukkit - update last location
+        this.lastPosX = this.targetPos.x;
+        this.lastPosY = this.targetPos.y;
+        this.lastPosZ = this.targetPos.z;
+        this.lastYaw = f;
+        this.lastPitch = f1;
+        // CraftBukkit end
+
         if (++this.teleportId == Integer.MAX_VALUE)
         {
             this.teleportId = 0;
@@ -630,6 +852,7 @@
     public void processPlayerDigging(CPacketPlayerDigging packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
+        if (this.player.isMovementBlocked()) return;
         WorldServer worldserver = this.serverController.getWorld(this.player.dimension);
         BlockPos blockpos = packetIn.getPosition();
         this.player.markPlayerActive();
@@ -641,7 +864,17 @@
                 if (!this.player.isSpectator())
                 {
                     ItemStack itemstack = this.player.getHeldItem(EnumHand.OFF_HAND);
+                    /* CraftBukkit start
                     this.player.setHeldItem(EnumHand.OFF_HAND, this.player.getHeldItem(EnumHand.MAIN_HAND));
+                    */
+                    org.bukkit.event.player.PlayerSwapHandItemsEvent swapItemsEvent = new org.bukkit.event.player.PlayerSwapHandItemsEvent(getPlayer(), org.bukkit.craftbukkit.inventory.CraftItemStack.asBukkitCopy(itemstack), org.bukkit.craftbukkit.inventory.CraftItemStack.asBukkitCopy(this.player.getHeldItem(EnumHand.MAIN_HAND)));
+                    this.server.getPluginManager().callEvent(swapItemsEvent);
+                    
+                    if (swapItemsEvent.isCancelled()) return;
+                    
+                    itemstack = org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(swapItemsEvent.getMainHandItem());
+                    this.player.setHeldItem(EnumHand.OFF_HAND, org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(swapItemsEvent.getOffHandItem()));
+                    // CraftBukkit end
                     this.player.setHeldItem(EnumHand.MAIN_HAND, itemstack);
                 }
 
@@ -650,6 +883,22 @@
 
                 if (!this.player.isSpectator())
                 {
+                    //Craftbukkit start
+                    // limit how quickly items can be dropped TODO check if it doesn't interfere with mods
+                    // If the ticks aren't the same then the count starts from 0 and we update the lastDropTick.
+                    if (this.lastDropTick != MinecraftServer.currentTick) {
+                        this.dropCount = 0;
+                        this.lastDropTick = MinecraftServer.currentTick;
+                    } else {
+                        // Else we increment the drop count and check the amount.
+                        this.dropCount++;
+                        if (this.dropCount >= 20) {
+                            LOGGER.warn(this.player.getName() + " dropped their items too quickly!");
+                            this.disconnect("You dropped your items too quickly (Hacking?)");
+                            return;
+                        }
+                    }
+                    //Craftbukkit end
                     this.player.dropItem(false);
                 }
 
@@ -694,6 +943,7 @@
                         }
                         else
                         {
+                            org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerInteractEvent(this.player, org.bukkit.event.block.Action.LEFT_CLICK_BLOCK, blockpos, packetIn.getFacing(), this.player.inventory.getCurrentItem(), EnumHand.MAIN_HAND); // CraftBukkit - fire PlayerInteractEvent
                             this.player.connection.sendPacket(new SPacketBlockChange(worldserver, blockpos));
                         }
                     }
@@ -725,6 +975,7 @@
     public void processTryUseItemOnBlock(CPacketPlayerTryUseItemOnBlock packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
+        if (this.player.isMovementBlocked()) return; //Craftbukkit
         WorldServer worldserver = this.serverController.getWorld(this.player.dimension);
         EnumHand enumhand = packetIn.getHand();
         ItemStack itemstack = this.player.getHeldItem(enumhand);
@@ -755,6 +1006,7 @@
     public void processTryUseItem(CPacketPlayerTryUseItem packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
+        if (this.player.isMovementBlocked()) return; //Craftbukkit
         WorldServer worldserver = this.serverController.getWorld(this.player.dimension);
         EnumHand enumhand = packetIn.getHand();
         ItemStack itemstack = this.player.getHeldItem(enumhand);
@@ -774,7 +1026,10 @@
         {
             Entity entity = null;
 
+            /* CraftBukkit - use the worlds array list TODO if we revert, what are the consequences?
             for (WorldServer worldserver : this.serverController.worlds)
+             */
+            for (WorldServer worldserver : this.serverController.worldServerList)
             {
                 if (worldserver != null)
                 {
@@ -796,7 +1051,7 @@
                 {
                     this.player.setPositionAndUpdate(entity.posX, entity.posY, entity.posZ);
                 }
-                else if (net.minecraftforge.common.ForgeHooks.onTravelToDimension(this.player, entity.dimension))
+                else if (net.minecraftforge.common.ForgeHooks.onTravelToDimension(this.player, entity.dimension)) //TODO teleporting stuff and events check
                 {
                     int prevDimension = this.player.dimension;
                     WorldServer worldserver1 = this.player.getServerWorld();
@@ -829,6 +1084,10 @@
 
     public void handleResourcePackStatus(CPacketResourcePackStatus packetIn)
     {
+        //Craftbukkit start
+        PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
+        this.server.getPluginManager().callEvent(new org.bukkit.event.player.PlayerResourcePackStatusEvent(getPlayer(), org.bukkit.event.player.PlayerResourcePackStatusEvent.Status.values()[packetIn.action.ordinal()]));
+        //Craftbukkit end
     }
 
     public void processSteerBoat(CPacketSteerBoat packetIn)
@@ -844,13 +1103,27 @@
 
     public void onDisconnect(ITextComponent reason)
     {
+        // CraftBukkit start - Rarely it would send a disconnect line twice
+        if (this.processedDisconnect) return;
+        else this.processedDisconnect = true;
+        // CraftBukkit end
         LOGGER.info("{} lost connection: {}", this.player.getName(), reason.getUnformattedText());
         this.serverController.refreshStatusNextTick();
+        // CraftBukkit start - Replace vanilla quit message handling with our own.
+        /*
         TextComponentTranslation textcomponenttranslation = new TextComponentTranslation("multiplayer.player.left", new Object[] {this.player.getDisplayName()});
         textcomponenttranslation.getStyle().setColor(TextFormatting.YELLOW);
         this.serverController.getPlayerList().sendMessage(textcomponenttranslation);
+        */
+        //Craftbukkit end
         this.player.mountEntityAndWakeUp();
+        /* Craftbukkit start - TODO rework with playerLoggedOut in PlayerList below
         this.serverController.getPlayerList().playerLoggedOut(this.player);
+        */
+        String quitMessage = this.serverController.getPlayerList().playerLoggedOut(this.player);
+        if ((quitMessage != null) && (quitMessage.length() > 0)) {
+            this.serverController.getPlayerList().sendMessage(org.bukkit.craftbukkit.util.CraftChatMessage.fromString(quitMessage));
+        }
 
         if (this.serverController.isSinglePlayer() && this.player.getName().equals(this.serverController.getServerOwner()))
         {
@@ -876,6 +1149,14 @@
                 return;
             }
         }
+        //Craftbukkit start - set compass target TODO rework as in ForgeKit?
+        if (packetIn == null) {
+            return;
+        } else if (packetIn instanceof net.minecraft.network.play.server.SPacketSpawnPosition) {
+            net.minecraft.network.play.server.SPacketSpawnPosition packet6 = (net.minecraft.network.play.server.SPacketSpawnPosition)packetIn;
+            this.player.compassTarget = new org.bukkit.Location(this.getPlayer().getWorld(), packet6.spawnBlockPos.getX(), packet6.spawnBlockPos.getY(), packet6.spawnBlockPos.getZ());
+        }
+        //Craftbukkit end
 
         try
         {
@@ -900,19 +1181,35 @@
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
 
+        if (this.player.isMovementBlocked()) return; //Craftbukkit
         if (packetIn.getSlotId() >= 0 && packetIn.getSlotId() < InventoryPlayer.getHotbarSize())
         {
+            //Craftbukkit start - held item change event
+            org.bukkit.event.player.PlayerItemHeldEvent event = new org.bukkit.event.player.PlayerItemHeldEvent(this.getPlayer(), this.player.inventory.currentItem, packetIn.getSlotId());
+            this.server.getPluginManager().callEvent(event);
+            if (event.isCancelled()) { //revert the change
+                this.sendPacket(new SPacketHeldItemChange(this.player.inventory.currentItem));
+                this.player.markPlayerActive();
+                return;
+            }
+            //Craftbukkit end
             this.player.inventory.currentItem = packetIn.getSlotId();
             this.player.markPlayerActive();
         }
         else
         {
             LOGGER.warn("{} tried to set an invalid carried item", (Object)this.player.getName());
+            this.disconnect("Nope!"); // CraftBukkit TODO is this really needed?
         }
     }
 
     public void processChatMessage(CPacketChatMessage packetIn)
     {
+        // CraftBukkit start - async chat
+        // SPIGOT-3638
+        if (this.serverController.isServerStopped()) return;
+        if (packetIn.getMessage().startsWith("/"))
+        //Craftbukkit end
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
 
         if (this.player.getChatVisibility() == EntityPlayer.EnumChatVisibility.HIDDEN)
@@ -931,6 +1228,27 @@
             {
                 if (!ChatAllowedCharacters.isAllowedCharacter(s.charAt(i)))
                 {
+                    // CraftBukkit start - threadsafety
+                    if (!s.startsWith("/")) {
+                        org.bukkit.craftbukkit.util.Waitable waitable = new org.bukkit.craftbukkit.util.Waitable() {
+                            @Override
+                            protected Object evaluate() {
+                                NetHandlerPlayServer.this.disconnect(new TextComponentTranslation("multiplayer.disconnect.illegal_characters", new Object[0]));
+                                return null;
+                            }
+                        };
+
+                        this.serverController.processQueue.add(waitable);
+
+                        try {
+                            waitable.get();
+                        } catch (InterruptedException e) {
+                            Thread.currentThread().interrupt();
+                        } catch (java.util.concurrent.ExecutionException e) {
+                            throw new RuntimeException(e);
+                        }
+                    } else
+                    // CraftBukkit end
                     this.disconnect(new TextComponentTranslation("multiplayer.disconnect.illegal_characters", new Object[0]));
                     return;
                 }
@@ -938,8 +1256,18 @@
 
             if (s.startsWith("/"))
             {
+                try { this.serverController.server.playerCommandState = true; //Craftbukkit ??? TODO explanation
                 this.handleSlashCommand(s);
+                } finally { this.serverController.server.playerCommandState = false; } //Craftbukkit
             }
+            //Craftbukkit start - conversation stuff TODO move to forge event?
+            else if (this.getPlayer().isConversing()) getPlayer().acceptConversationInput(s);
+            else if (this.player.getChatVisibility() == EntityPlayer.EnumChatVisibility.SYSTEM) { // Re-add "Command Only" flag check
+                TextComponentTranslation chatmessage = new TextComponentTranslation("chat.cannotSend", new Object[0]);
+                chatmessage.getStyle().setColor(TextFormatting.RED);
+                this.sendPacket(new SPacketChat(chatmessage));
+            }
+            //Craftbukkit end
             else
             {
                 ITextComponent itextcomponent = new TextComponentTranslation("chat.type.text", this.player.getDisplayName(), net.minecraftforge.common.ForgeHooks.newChatWithLinks(s));
@@ -948,10 +1276,34 @@
                 this.serverController.getPlayerList().sendMessage(itextcomponent, false);
             }
 
+            // CraftBukkit start - replaced with thread safe throttle
+            /*
             this.chatSpamThresholdCount += 20;
 
             if (this.chatSpamThresholdCount > 200 && !this.serverController.getPlayerList().canSendCommands(this.player.getGameProfile()))
             {
+            */
+            if (chatSpamField.addAndGet(this, 20) > 200 && !this.serverController.getPlayerList().canSendCommands(this.player.getGameProfile())) {
+                if (!s.startsWith("/")) {
+                    org.bukkit.craftbukkit.util.Waitable waitable = new org.bukkit.craftbukkit.util.Waitable() {
+                        @Override
+                        protected Object evaluate() {
+                            NetHandlerPlayServer.this.disconnect(new TextComponentTranslation("disconnect.spam", new Object[0]));
+                            return null;
+                        }
+                    };
+
+                    this.serverController.processQueue.add(waitable);
+
+                    try {
+                        waitable.get();
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                    } catch (java.util.concurrent.ExecutionException e) {
+                        throw new RuntimeException(e);
+                    }
+                } else
+                // CraftBukkit end
                 this.disconnect(new TextComponentTranslation("disconnect.spam", new Object[0]));
             }
         }
@@ -959,33 +1311,96 @@
 
     private void handleSlashCommand(String command)
     {
+        // CraftBukkit start - whole method TODO check commands
+        /*
         this.serverController.getCommandManager().executeCommand(this.player, command);
+        */
+        this.LOGGER.info(this.player.getName() + " issued server command: " + command);
+        org.bukkit.craftbukkit.entity.CraftPlayer player = this.getPlayer();
+        org.bukkit.event.player.PlayerCommandPreprocessEvent event = new org.bukkit.event.player.PlayerCommandPreprocessEvent(player, command, new org.bukkit.craftbukkit.util.LazyPlayerSet(serverController));
+        this.server.getPluginManager().callEvent(event);
+        
+        if (event.isCancelled()) return;
+        
+        command = event.getMessage();
+        this.serverController.getCommandManager().executeCommand(((org.bukkit.craftbukkit.entity.CraftPlayer)event.getPlayer()).getHandle(), command);
+        // CraftBukkit end
     }
 
     public void handleAnimation(CPacketAnimation packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
+        if (this.player.isMovementBlocked()) return; //Craftbukkit
         this.player.markPlayerActive();
+        // CraftBukkit start - Raytrace to look for 'rogue armswings' TODO shrink and move to LavaEventFactory
+        float f1 = this.player.rotationPitch;
+        float f2 = this.player.rotationYaw;
+        double d0 = this.player.posX;
+        double d1 = this.player.posY + (double) this.player.getEyeHeight();
+        double d2 = this.player.posZ;
+        Vec3d vec3d = new Vec3d(d0, d1, d2);
+        float f3 = MathHelper.cos(-f2 * 0.017453292F - 3.1415927F);
+        float f4 = MathHelper.sin(-f2 * 0.017453292F - 3.1415927F);
+        float f5 = -MathHelper.cos(-f1 * 0.017453292F);
+        float f6 = MathHelper.sin(-f1 * 0.017453292F);
+        float f7 = f4 * f5;
+        float f8 = f3 * f5;
+        double d3 = player.interactionManager.getGameType() == GameType.CREATIVE ? 5.0D : 4.5D;
+        Vec3d vec3d1 = vec3d.addVector((double) f7 * d3, (double) f6 * d3, (double) f8 * d3);
+        net.minecraft.util.math.RayTraceResult movingobjectposition = this.player.world.rayTraceBlocks(vec3d, vec3d1, false);
+        
+        if (movingobjectposition == null || movingobjectposition.typeOfHit != net.minecraft.util.math.RayTraceResult.Type.BLOCK) org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerInteractEvent(this.player, org.bukkit.event.block.Action.LEFT_CLICK_AIR, this.player.inventory.getCurrentItem(), EnumHand.MAIN_HAND);
+        
+        org.bukkit.event.player.PlayerAnimationEvent event = new org.bukkit.event.player.PlayerAnimationEvent(this.getPlayer());
+        this.server.getPluginManager().callEvent(event);
+
+        if (event.isCancelled()) return;
+        // CraftBukkit end
         this.player.swingArm(packetIn.getHand());
     }
 
     public void processEntityAction(CPacketEntityAction packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
+        if (this.player.isDead) return; //Craftbukkit
         this.player.markPlayerActive();
 
         switch (packetIn.getAction())
         {
             case START_SNEAKING:
+                //Lava-test start - event TODO move to LavaEventFactory
+                org.bukkit.event.player.PlayerToggleSneakEvent e = new org.bukkit.event.player.PlayerToggleSneakEvent(this.getPlayer(), true);
+                this.server.getPluginManager().callEvent(e);
+
+                if (e.isCancelled()) return;
+                //Lava-test end
                 this.player.setSneaking(true);
                 break;
             case STOP_SNEAKING:
+                //Lava-test start - event TODO move to LavaEventFactory
+                org.bukkit.event.player.PlayerToggleSneakEvent e1 = new org.bukkit.event.player.PlayerToggleSneakEvent(this.getPlayer(), false);
+                this.server.getPluginManager().callEvent(e1);
+
+                if (e1.isCancelled()) return;
+                //Lava-test end
                 this.player.setSneaking(false);
                 break;
             case START_SPRINTING:
+                //Lava-test start - event TODO move to LavaEventFactory for a one liner
+                org.bukkit.event.player.PlayerToggleSprintEvent e2 = new org.bukkit.event.player.PlayerToggleSprintEvent(this.getPlayer(), true);
+                this.server.getPluginManager().callEvent(e2);
+
+                if (e2.isCancelled()) return;
+                //Lava-test end
                 this.player.setSprinting(true);
                 break;
             case STOP_SPRINTING:
+                //Lava-test start - event TODO move to LavaEventFactory for a one liner
+                org.bukkit.event.player.PlayerToggleSprintEvent e3 = new org.bukkit.event.player.PlayerToggleSprintEvent(this.getPlayer(), false);
+                this.server.getPluginManager().callEvent(e3);
+
+                if (e3.isCancelled()) return;
+                //Lava-test end
                 this.player.setSprinting(false);
                 break;
             case STOP_SLEEPING:
@@ -1053,6 +1468,7 @@
     public void processUseEntity(CPacketUseEntity packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
+        if (this.player.isMovementBlocked()) return; //Craftbukkit
         WorldServer worldserver = this.serverController.getWorld(this.player.dimension);
         Entity entity = packetIn.getEntityFromWorld(worldserver);
         this.player.markPlayerActive();
@@ -1069,20 +1485,52 @@
 
             if (this.player.getDistanceSq(entity) < d0)
             {
+                //Craftbukkit start //Lava-test - TODO move to LavaEventFactory
+                ItemStack itemInHand = this.player.getHeldItem(packetIn.getHand() == null ? EnumHand.MAIN_HAND : packetIn.getHand());
+
+                if (packetIn.getAction() == CPacketUseEntity.Action.INTERACT || packetIn.getAction() == CPacketUseEntity.Action.INTERACT_AT) {
+                    // CraftBukkit start
+                    boolean triggerLeashUpdate = itemInHand != null && itemInHand.getItem() == Items.LEAD && entity instanceof net.minecraft.entity.EntityLiving;
+                    net.minecraft.item.Item origItem = this.player.inventory.getCurrentItem() == null ? null : this.player.inventory.getCurrentItem().getItem();
+                    org.bukkit.event.player.PlayerInteractEntityEvent event;
+                    if (packetIn.getAction() == CPacketUseEntity.Action.INTERACT) {
+                        event = new org.bukkit.event.player.PlayerInteractEntityEvent((org.bukkit.entity.Player) this.getPlayer(), entity.getBukkitEntity(), (packetIn.getHand() == EnumHand.OFF_HAND) ? org.bukkit.inventory.EquipmentSlot.OFF_HAND : org.bukkit.inventory.EquipmentSlot.HAND);
+                    } else {
+                        Vec3d target = packetIn.getHitVec();
+                        event = new org.bukkit.event.player.PlayerInteractAtEntityEvent((org.bukkit.entity.Player) this.getPlayer(), entity.getBukkitEntity(), new org.bukkit.util.Vector(target.x, target.y, target.z), (packetIn.getHand() == EnumHand.OFF_HAND) ? org.bukkit.inventory.EquipmentSlot.OFF_HAND : org.bukkit.inventory.EquipmentSlot.HAND);
+                    }
+                    this.server.getPluginManager().callEvent(event);
+
+                    if (triggerLeashUpdate && (event.isCancelled() || this.player.inventory.getCurrentItem() == null || this.player.inventory.getCurrentItem().getItem() != Items.LEAD)) {
+                        // Refresh the current leash state
+                        this.sendPacket(new net.minecraft.network.play.server.SPacketEntityAttach(entity, ((net.minecraft.entity.EntityLiving) entity).getLeashHolder()));
+                    }
+
+                    if (event.isCancelled() || this.player.inventory.getCurrentItem() == null || this.player.inventory.getCurrentItem().getItem() != origItem) {
+                        // Refresh the current entity metadata
+                        this.sendPacket(new net.minecraft.network.play.server.SPacketEntityMetadata(entity.getEntityId(), entity.getDataManager(), true));
+                    }
+
+                    if (event.isCancelled()) return;
+                }
+                // CraftBukkit end
+
                 if (packetIn.getAction() == CPacketUseEntity.Action.INTERACT)
                 {
                     EnumHand enumhand = packetIn.getHand();
                     this.player.interactOn(entity, enumhand);
+                    if (!itemInHand.isEmpty() && itemInHand.getCount() <= -1) this.player.sendContainerToPlayer(this.player.openContainer); //Craftbukkit - ???
                 }
                 else if (packetIn.getAction() == CPacketUseEntity.Action.INTERACT_AT)
                 {
                     EnumHand enumhand1 = packetIn.getHand();
                     if(net.minecraftforge.common.ForgeHooks.onInteractEntityAt(player, entity, packetIn.getHitVec(), enumhand1) != null) return;
                     entity.applyPlayerInteraction(this.player, packetIn.getHitVec(), enumhand1);
+                    if (!itemInHand.isEmpty() && itemInHand.getCount() <= -1) this.player.sendContainerToPlayer(this.player.openContainer); //Craftbukkit
                 }
                 else if (packetIn.getAction() == CPacketUseEntity.Action.ATTACK)
                 {
-                    if (entity instanceof EntityItem || entity instanceof EntityXPOrb || entity instanceof EntityArrow || entity == this.player)
+                    if (entity instanceof EntityItem || entity instanceof EntityXPOrb || entity instanceof EntityArrow || (entity == this.player /*Craftbukkit - add check*/ && !player.isSpectator()))
                     {
                         this.disconnect(new TextComponentTranslation("multiplayer.disconnect.invalid_entity_attacked", new Object[0]));
                         this.serverController.logWarning("Player " + this.player.getName() + " tried to attack an invalid entity");
@@ -1090,6 +1538,7 @@
                     }
 
                     this.player.attackTargetEntityWithCurrentItem(entity);
+                    if (!itemInHand.isEmpty() && itemInHand.getCount() <= -1) this.player.sendContainerToPlayer(this.player.openContainer); //Craftbukkit
                 }
             }
         }
@@ -1108,7 +1557,11 @@
                 if (this.player.queuedEndExit)
                 {
                     this.player.queuedEndExit = false;
+                    /* Craftbukkit start - reroute logic through custom portal management TODO teleporting stuff
                     this.player = this.serverController.getPlayerList().recreatePlayerEntity(this.player, 0, true);
+                    */
+                    this.serverController.getPlayerList().changeDimension(this.player, 0, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.END_PORTAL);
+                    //Craftbukkit end
                     CriteriaTriggers.CHANGED_DIMENSION.trigger(this.player, DimensionType.THE_END, DimensionType.OVERWORLD);
                 }
                 else
@@ -1136,16 +1589,22 @@
     public void processCloseWindow(CPacketCloseWindow packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
+        //Craftbukkit start
+        if (this.player.isMovementBlocked()) return;
+        org.bukkit.craftbukkit.event.CraftEventFactory.handleInventoryCloseEvent(this.player); //check if we can move to event in method below TODO
+        //Craftbukkit end
         this.player.closeContainer();
     }
 
     public void processClickWindow(CPacketClickWindow packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
+        if (this.player.isMovementBlocked()) return; //Craftbukkit
         this.player.markPlayerActive();
 
-        if (this.player.openContainer.windowId == packetIn.getWindowId() && this.player.openContainer.getCanCraft(this.player))
+        if (this.player.openContainer.windowId == packetIn.getWindowId() && this.player.openContainer.getCanCraft(this.player) /*Craftbukkit - add check*/ && this.player.openContainer.canInteractWith(this.player))
         {
+            /*
             if (this.player.isSpectator())
             {
                 NonNullList<ItemStack> nonnulllist = NonNullList.<ItemStack>create();
@@ -1160,7 +1619,256 @@
             else
             {
                 ItemStack itemstack2 = this.player.openContainer.slotClick(packetIn.getSlotId(), packetIn.getUsedButton(), packetIn.getClickType(), this.player);
+                */
+            {   // CraftBukkit start - Call InventoryClickEvent TODO move to LavaEventFactory, I don't really have time for this now
+                if (packetIn.getSlotId() < -1 && packetIn.getSlotId() != -999) return;
 
+                org.bukkit.inventory.InventoryView inventory = this.player.openContainer.getBukkitView();
+
+                // Lava start
+                if (inventory == null) {
+                    inventory = new org.bukkit.craftbukkit.inventory.CraftInventoryView(this.player.getBukkitEntity(), MinecraftServer.getServerInstance().server.createInventory(this.player.getBukkitEntity(), org.bukkit.event.inventory.InventoryType.CHEST), this.player.openContainer);
+                    this.player.openContainer.setBukkitView(inventory);
+                }
+                // Lava end
+
+                org.bukkit.event.inventory.InventoryType.SlotType type = org.bukkit.craftbukkit.inventory.CraftInventoryView.getSlotType(inventory, packetIn.getSlotId());
+
+                org.bukkit.event.inventory.InventoryClickEvent event;
+                org.bukkit.event.inventory.ClickType click = org.bukkit.event.inventory.ClickType.UNKNOWN;
+                org.bukkit.event.inventory.InventoryAction action = org.bukkit.event.inventory.InventoryAction.UNKNOWN;
+
+                ItemStack itemstack2 = ItemStack.EMPTY;
+
+                switch (packetIn.getClickType()) {
+                    case PICKUP:
+                        if (packetIn.getUsedButton() == 0)
+                            click = org.bukkit.event.inventory.ClickType.LEFT;
+                        else if (packetIn.getUsedButton() == 1)
+                            click = org.bukkit.event.inventory.ClickType.RIGHT;
+                        if (packetIn.getUsedButton() == 0 || packetIn.getUsedButton() == 1) {
+                            action = org.bukkit.event.inventory.InventoryAction.NOTHING; // Don't want to repeat ourselves
+                            if (packetIn.getSlotId() == -999)
+                                if (!player.inventory.getItemStack().isEmpty())
+                                    action = packetIn.getUsedButton() == 0 ? org.bukkit.event.inventory.InventoryAction.DROP_ALL_CURSOR : org.bukkit.event.inventory.InventoryAction.DROP_ONE_CURSOR;
+                            else if (packetIn.getSlotId() < 0)
+                                action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                            else {
+                                Slot slot = this.player.openContainer.getSlot(packetIn.getSlotId());
+                                
+                                if (slot != null) {
+                                    ItemStack clickedItem = slot.getStack();
+                                    ItemStack cursor = player.inventory.getItemStack();
+                                    
+                                    if (clickedItem.isEmpty())
+                                        if (!cursor.isEmpty())
+                                            action = packetIn.getUsedButton() == 0 ? org.bukkit.event.inventory.InventoryAction.PLACE_ALL : org.bukkit.event.inventory.InventoryAction.PLACE_ONE;
+                                    else if (slot.canTakeStack(player)) {
+                                        if (cursor.isEmpty())
+                                            action = packetIn.getUsedButton() == 0 ? org.bukkit.event.inventory.InventoryAction.PICKUP_ALL : org.bukkit.event.inventory.InventoryAction.PICKUP_HALF;
+                                        else if (slot.isItemValid(cursor)) {
+                                            if (clickedItem.isItemEqual(cursor) && ItemStack.areItemStackTagsEqual(clickedItem, cursor)) {
+                                                int toPlace = packetIn.getUsedButton() == 0 ? cursor.getCount() : 1;
+                                                toPlace = Math.min(toPlace, clickedItem.getMaxStackSize() - clickedItem.getCount());
+                                                toPlace = Math.min(toPlace, slot.inventory.getInventoryStackLimit() - clickedItem.getCount());
+                                                
+                                                if (toPlace == 1)
+                                                    action = org.bukkit.event.inventory.InventoryAction.PLACE_ONE;
+                                                else if (toPlace == cursor.getCount())
+                                                    action = org.bukkit.event.inventory.InventoryAction.PLACE_ALL;
+                                                else if (toPlace < 0)
+                                                    action = toPlace != -1 ? org.bukkit.event.inventory.InventoryAction.PICKUP_SOME : org.bukkit.event.inventory.InventoryAction.PICKUP_ONE; // this happens with oversized stacks
+                                                else if (toPlace != 0)
+                                                    action = org.bukkit.event.inventory.InventoryAction.PLACE_SOME;
+                                            } else if (cursor.getCount() <= slot.getSlotStackLimit())
+                                                action = org.bukkit.event.inventory.InventoryAction.SWAP_WITH_CURSOR;
+                                        }
+                                        else if (cursor.getItem() == clickedItem.getItem() && (!cursor.getHasSubtypes() || cursor.getMetadata() == clickedItem.getMetadata()) && ItemStack.areItemStackTagsEqual(cursor, clickedItem))
+                                            if (clickedItem.getCount() >= 0)
+                                                if (clickedItem.getCount() + cursor.getCount() <= cursor.getMaxStackSize())
+                                                    // As of 1.5, this is result slots only
+                                                    action = org.bukkit.event.inventory.InventoryAction.PICKUP_ALL;
+                                    }
+                                }
+                            }
+                        }
+                        break;
+                    case QUICK_MOVE:
+                        if (packetIn.getUsedButton() == 0)
+                            click = org.bukkit.event.inventory.ClickType.SHIFT_LEFT;
+                        else if (packetIn.getUsedButton() == 1)
+                            click = org.bukkit.event.inventory.ClickType.SHIFT_RIGHT;
+                        if (packetIn.getUsedButton() == 0 || packetIn.getUsedButton() == 1) {
+                            if (packetIn.getSlotId() < 0)
+                                action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                            else {
+                                Slot slot = this.player.openContainer.getSlot(packetIn.getSlotId());
+                                
+                                if (slot != null && slot.canTakeStack(this.player) && slot.getHasStack())
+                                    action = org.bukkit.event.inventory.InventoryAction.MOVE_TO_OTHER_INVENTORY;
+                                else
+                                    action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                                }
+                            }
+                        break;
+                    case SWAP:
+                        if (packetIn.getUsedButton() >= 0 && packetIn.getUsedButton() < 9) {
+                            click = org.bukkit.event.inventory.ClickType.NUMBER_KEY;
+                            Slot clickedSlot = this.player.openContainer.getSlot(packetIn.getSlotId());
+                            
+                            if (clickedSlot.canTakeStack(player)) {
+                                ItemStack hotbar = this.player.inventory.getStackInSlot(packetIn.getUsedButton());
+                                boolean canCleanSwap = hotbar.isEmpty() || (clickedSlot.inventory == player.inventory && clickedSlot.isItemValid(hotbar)); // the slot will accept the hotbar item
+                                
+                                if (clickedSlot.getHasStack()) {
+                                    if (canCleanSwap)
+                                        action = org.bukkit.event.inventory.InventoryAction.HOTBAR_SWAP;
+                                    else
+                                        action = org.bukkit.event.inventory.InventoryAction.HOTBAR_MOVE_AND_READD;
+                                } else if (!clickedSlot.getHasStack() && !hotbar.isEmpty() && clickedSlot.isItemValid(hotbar))
+                                    action = org.bukkit.event.inventory.InventoryAction.HOTBAR_SWAP;
+                                else
+                                    action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                            } else
+                                action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                        }
+                        break;
+                    case CLONE:
+                        if (packetIn.getUsedButton() == 2) {
+                            click = org.bukkit.event.inventory.ClickType.MIDDLE;
+                            
+                            if (packetIn.getSlotId() == -999)
+                                action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                            else {
+                                Slot slot = this.player.openContainer.getSlot(packetIn.getSlotId());
+                                
+                                if (slot != null && slot.getHasStack() && player.capabilities.isCreativeMode && player.inventory.getItemStack().isEmpty())
+                                    action = org.bukkit.event.inventory.InventoryAction.CLONE_STACK;
+                                else
+                                    action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                            }
+                        } else {
+                            click = org.bukkit.event.inventory.ClickType.UNKNOWN;
+                            action = org.bukkit.event.inventory.InventoryAction.UNKNOWN;
+                        }
+                        break;
+                    case THROW:
+                        if (packetIn.getSlotId() >= 0) {
+                            if (packetIn.getUsedButton() == 0) {
+                                click = org.bukkit.event.inventory.ClickType.DROP;
+                                Slot slot = this.player.openContainer.getSlot(packetIn.getSlotId());
+                                
+                                if (slot != null && slot.getHasStack() && slot.canTakeStack(player) && !slot.getStack().isEmpty() && slot.getStack().getItem() != net.minecraft.item.Item.getItemFromBlock(Blocks.AIR))
+                                    action = org.bukkit.event.inventory.InventoryAction.DROP_ONE_SLOT;
+                                else
+                                    action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                            } else if (packetIn.getUsedButton() == 1) {
+                                click = org.bukkit.event.inventory.ClickType.CONTROL_DROP;
+                                Slot slot = this.player.openContainer.getSlot(packetIn.getSlotId());
+                                
+                                if (slot != null && slot.getHasStack() && slot.canTakeStack(player) && !slot.getStack().isEmpty() && slot.getStack().getItem() != net.minecraft.item.Item.getItemFromBlock(Blocks.AIR))
+                                    action = org.bukkit.event.inventory.InventoryAction.DROP_ALL_SLOT;
+                                else
+                                    action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                            }
+                        } else {
+                            click = org.bukkit.event.inventory.ClickType.LEFT;
+                            
+                            if (packetIn.getUsedButton() == 1)
+                                click = org.bukkit.event.inventory.ClickType.RIGHT;
+                            action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                        }
+                        break;
+                    case QUICK_CRAFT:
+                        itemstack2 = this.player.openContainer.slotClick(packetIn.getSlotId(), packetIn.getUsedButton(), packetIn.getClickType(), this.player);
+                        break;
+                    case PICKUP_ALL:
+                        click = org.bukkit.event.inventory.ClickType.DOUBLE_CLICK;
+                        action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+                        if (packetIn.getSlotId() >= 0 && !this.player.inventory.getItemStack().isEmpty()) {
+                            ItemStack cursor = this.player.inventory.getItemStack();
+                            action = org.bukkit.event.inventory.InventoryAction.NOTHING;
+
+                            if (inventory.getTopInventory().contains(org.bukkit.Material.getMaterial(net.minecraft.item.Item.getIdFromItem(cursor.getItem()))) || inventory.getBottomInventory().contains(org.bukkit.Material.getMaterial(net.minecraft.item.Item.getIdFromItem(cursor.getItem()))))
+                                action = org.bukkit.event.inventory.InventoryAction.COLLECT_TO_CURSOR;
+                        }
+                        break;
+                    default:
+                        break;
+                }
+
+                if (packetIn.getClickType() != net.minecraft.inventory.ClickType.QUICK_CRAFT) {
+                    if (click == org.bukkit.event.inventory.ClickType.NUMBER_KEY)
+                        event = new org.bukkit.event.inventory.InventoryClickEvent(inventory, type, packetIn.getSlotId(), click, action, packetIn.getUsedButton());
+                    else
+                        event = new org.bukkit.event.inventory.InventoryClickEvent(inventory, type, packetIn.getSlotId(), click, action);
+
+                    org.bukkit.inventory.Inventory top = inventory.getTopInventory();
+                    
+                    if (packetIn.getSlotId() == 0 && top instanceof org.bukkit.inventory.CraftingInventory) {
+                        org.bukkit.inventory.Recipe recipe = ((org.bukkit.inventory.CraftingInventory) top).getRecipe();
+                        
+                        if (recipe != null) {
+                            if (click == org.bukkit.event.inventory.ClickType.NUMBER_KEY)
+                                event = new org.bukkit.event.inventory.CraftItemEvent(recipe, inventory, type, packetIn.getSlotId(), click, action, packetIn.getUsedButton());
+                            else
+                                event = new org.bukkit.event.inventory.CraftItemEvent(recipe, inventory, type, packetIn.getSlotId(), click, action);
+                        }
+                    }
+
+                    event.setCancelled(this.player.isSpectator());
+                    Container oldContainer = this.player.openContainer; // SPIGOT-1224
+                    server.getPluginManager().callEvent(event);
+                    if (this.player.openContainer != oldContainer) return;
+                    switch (event.getResult()) {
+                        case ALLOW:
+                        case DEFAULT:
+                            itemstack2 = this.player.openContainer.slotClick(packetIn.getSlotId(), packetIn.getUsedButton(), packetIn.getClickType(), this.player);
+                            break;
+                        case DENY:
+                            switch (action) {
+                                // Modified other slots
+                                case PICKUP_ALL:
+                                case MOVE_TO_OTHER_INVENTORY:
+                                case HOTBAR_MOVE_AND_READD:
+                                case HOTBAR_SWAP:
+                                case COLLECT_TO_CURSOR:
+                                case UNKNOWN:
+                                    this.player.sendContainerToPlayer(this.player.openContainer);
+                                    break;
+                                // Modified cursor and clicked
+                                case PICKUP_SOME:
+                                case PICKUP_HALF:
+                                case PICKUP_ONE:
+                                case PLACE_ALL:
+                                case PLACE_SOME:
+                                case PLACE_ONE:
+                                case SWAP_WITH_CURSOR:
+                                    this.player.connection.sendPacket(new SPacketSetSlot(-1, -1, this.player.inventory.getItemStack()));
+                                    this.player.connection.sendPacket(new SPacketSetSlot(this.player.openContainer.windowId, packetIn.getSlotId(), this.player.openContainer.getSlot(packetIn.getSlotId()).getStack()));
+                                    break;
+                                // Modified clicked only
+                                case DROP_ALL_SLOT:
+                                case DROP_ONE_SLOT:
+                                    this.player.connection.sendPacket(new SPacketSetSlot(this.player.openContainer.windowId, packetIn.getSlotId(), this.player.openContainer.getSlot(packetIn.getSlotId()).getStack()));
+                                    break;
+                                // Modified cursor only
+                                case DROP_ALL_CURSOR:
+                                case DROP_ONE_CURSOR:
+                                case CLONE_STACK:
+                                    this.player.connection.sendPacket(new SPacketSetSlot(-1, -1, this.player.inventory.getItemStack()));
+                                    break;
+                                // Nothing
+                                case NOTHING:
+                                    break;
+                            }
+                            return;
+                    }
+
+                    if (event instanceof org.bukkit.event.inventory.CraftItemEvent) player.sendContainerToPlayer(player.openContainer); //for custom recipes
+                }
+                // CraftBukkit end
+
                 if (ItemStack.areItemStacksEqualUsingNBTShareTag(packetIn.getClickedItem(), itemstack2))
                 {
                     this.player.connection.sendPacket(new SPacketConfirmTransaction(packetIn.getWindowId(), packetIn.getActionNumber(), true));
@@ -1203,6 +1911,7 @@
     public void processEnchantItem(CPacketEnchantItem packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
+        if (this.player.isMovementBlocked()) return; //Craftbukkit
         this.player.markPlayerActive();
 
         if (this.player.openContainer.windowId == packetIn.getWindowId() && this.player.openContainer.getCanCraft(this.player) && !this.player.isSpectator())
@@ -1243,7 +1952,43 @@
 
             boolean flag1 = packetIn.getSlotId() >= 1 && packetIn.getSlotId() <= 45;
             boolean flag2 = itemstack.isEmpty() || itemstack.getMetadata() >= 0 && itemstack.getCount() <= 64 && !itemstack.isEmpty();
+            // CraftBukkit start - Call click event
+            if (flag || (flag1 && !ItemStack.areItemStacksEqual(this.player.inventoryContainer.getSlot(packetIn.getSlotId()).getStack(), packetIn.getStack()))) { // Insist on valid slot TODO check Overpowered inventory compatibility
+                org.bukkit.inventory.InventoryView inventory = this.player.inventoryContainer.getBukkitView();
+                org.bukkit.inventory.ItemStack item = org.bukkit.craftbukkit.inventory.CraftItemStack.asBukkitCopy(packetIn.getStack());
 
+                org.bukkit.event.inventory.InventoryType.SlotType type = org.bukkit.event.inventory.InventoryType.SlotType.QUICKBAR;
+                if (flag)
+                    type = org.bukkit.event.inventory.InventoryType.SlotType.OUTSIDE;
+                else if (packetIn.getSlotId() < 36) {
+                    if (packetIn.getSlotId() >= 5 && packetIn.getSlotId() < 9)
+                        type = org.bukkit.event.inventory.InventoryType.SlotType.ARMOR;
+                    else
+                        type = org.bukkit.event.inventory.InventoryType.SlotType.CONTAINER;
+                }
+                org.bukkit.event.inventory.InventoryCreativeEvent event = new org.bukkit.event.inventory.InventoryCreativeEvent(inventory, type, flag ? -999 : packetIn.getSlotId(), item);
+                server.getPluginManager().callEvent(event);
+
+                itemstack = org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(event.getCursor());
+
+                switch (event.getResult()) {
+                    case ALLOW:
+                        // Plugin cleared the id / stacksize checks ///Lava-test - removed ID checks as something could probably create an item with that ID
+                        flag2 = true;
+                        break;
+                    case DEFAULT:
+                        break;
+                    case DENY:
+                        // Reset the slot
+                        if (packetIn.getSlotId() >= 0) {
+                            this.player.connection.sendPacket(new SPacketSetSlot(this.player.inventoryContainer.windowId, packetIn.getSlotId(), this.player.inventoryContainer.getSlot(packetIn.getSlotId()).getStack()));
+                            this.player.connection.sendPacket(new SPacketSetSlot(-1, -1, ItemStack.EMPTY));
+                        }
+                        return;
+                }
+            }
+            // CraftBukkit end
+
             if (flag1 && flag2)
             {
                 if (itemstack.isEmpty())
@@ -1273,6 +2018,7 @@
     public void processConfirmTransaction(CPacketConfirmTransaction packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
+        if (this.player.isMovementBlocked()) return; //Craftbukkit
         Short oshort = this.pendingTransactions.lookup(this.player.openContainer.windowId);
 
         if (oshort != null && packetIn.getUid() == oshort.shortValue() && this.player.openContainer.windowId == packetIn.getWindowId() && !this.player.openContainer.getCanCraft(this.player) && !this.player.isSpectator())
@@ -1284,6 +2030,7 @@
     public void processUpdateSign(CPacketUpdateSign packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
+        if (this.player.isMovementBlocked()) return; //Craftbukkit
         this.player.markPlayerActive();
         WorldServer worldserver = this.serverController.getWorld(this.player.dimension);
         BlockPos blockpos = packetIn.getPosition();
@@ -1303,16 +2050,34 @@
             if (!tileentitysign.getIsEditable() || tileentitysign.getPlayer() != this.player)
             {
                 this.serverController.logWarning("Player " + this.player.getName() + " just tried to change non-editable sign");
+                this.sendPacket(tileentity.getUpdatePacket()); //Craftbukkit?
                 return;
             }
 
             String[] astring = packetIn.getLines();
+            //Craftbukkit start - prepare for event
+            org.bukkit.entity.Player player = this.server.getPlayer(this.player);
+            int x = packetIn.getPosition().getX();
+            int y = packetIn.getPosition().getY();
+            int z = packetIn.getPosition().getZ();
+            String[] lines = new String[4];
+            //Craftbukkit end
 
             for (int i = 0; i < astring.length; ++i)
             {
                 tileentitysign.signText[i] = new TextComponentString(TextFormatting.getTextWithoutFormattingCodes(astring[i]));
+                lines[i] = TextFormatting.getTextWithoutFormattingCodes(new TextComponentString(TextFormatting.getTextWithoutFormattingCodes(astring[i])).getUnformattedText()); //Craftbukkit - store CB version of the lines
             }
+            //Craftbukkit start - event
+            org.bukkit.event.block.SignChangeEvent event = new org.bukkit.event.block.SignChangeEvent((org.bukkit.craftbukkit.block.CraftBlock) player.getWorld().getBlockAt(x, y, z), this.server.getPlayer(this.player), lines);
+            this.server.getPluginManager().callEvent(event);
 
+            if (!event.isCancelled()) {
+                System.arraycopy(org.bukkit.craftbukkit.block.CraftSign.sanitizeLines(event.getLines()), 0, tileentitysign.signText, 0, 4);
+                tileentitysign.isEditable = false;
+            }
+            //Craftbukkit end
+
             tileentitysign.markDirty();
             worldserver.notifyBlockUpdate(blockpos, iblockstate, iblockstate, 3);
         }
@@ -1320,6 +2085,7 @@
 
     public void processKeepAlive(CPacketKeepAlive packetIn)
     {
+        PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld()); //Craftbukkit ?
         if (this.field_194403_g && packetIn.getKey() == this.field_194404_h)
         {
             int i = (int)(this.currentTimeMillis() - this.field_194402_f);
@@ -1340,12 +2106,28 @@
     public void processPlayerAbilities(CPacketPlayerAbilities packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
+        /* Craftbukkit start - flying event
         this.player.capabilities.isFlying = packetIn.isFlying() && this.player.capabilities.allowFlying;
+        */
+        if (this.player.capabilities.allowFlying && this.player.capabilities.isFlying != packetIn.isFlying()) {
+            org.bukkit.event.player.PlayerToggleFlightEvent event = new org.bukkit.event.player.PlayerToggleFlightEvent(this.server.getPlayer(this.player), packetIn.isFlying());
+            this.server.getPluginManager().callEvent(event);
+            
+            if (!event.isCancelled()) this.player.capabilities.isFlying = packetIn.isFlying(); // Actually set the player's flying status
+            else this.player.sendPlayerAbilities(); // Tell the player their ability was reverted
+        }
+        //Craftbukkit end
     }
 
     public void processTabComplete(CPacketTabComplete packetIn)
     {
         PacketThreadUtil.checkThreadAndEnqueue(packetIn, this, this.player.getServerWorld());
+        //Craftbukkit start - spawm protection
+        if (chatSpamField.addAndGet(this, 10) > 500 && !this.serverController.getPlayerList().canSendCommands(this.player.getGameProfile())) {
+            this.disconnect(new TextComponentTranslation("disconnect.spam", new Object[0]));
+            return;
+        }
+        //Craftbukkit end
         List<String> list = Lists.<String>newArrayList();
 
         for (String s : this.serverController.getTabCompletions(this.player, packetIn.getMessage(), packetIn.getTargetBlock(), packetIn.hasTargetBlock()))
@@ -1369,6 +2151,14 @@
 
         if ("MC|BEdit".equals(s))
         {
+            //Craftbukkit start
+            if (this.lastBookTick + 20 > MinecraftServer.currentTick) {
+                this.disconnect("Book edited too quickly! If you have problems seeing this message while doing nothing illegal, contact your server admin or open an issue at Lava Github (google it)");
+                return;
+            }
+            
+            this.lastBookTick = MinecraftServer.currentTick;
+            //Craftbukkit end
             PacketBuffer packetbuffer = packetIn.getBufferData();
 
             try
@@ -1394,16 +2184,26 @@
 
                 if (itemstack.getItem() == Items.WRITABLE_BOOK && itemstack.getItem() == itemstack1.getItem())
                 {
+                    itemstack1 = new ItemStack(Items.WRITABLE_BOOK); //Craftbukkit ???
                     itemstack1.setTagInfo("pages", itemstack.getTagCompound().getTagList("pages", 8));
+                    org.bukkit.craftbukkit.event.CraftEventFactory.handleEditBookEvent(player, itemstack1); //Craftbukkit
                 }
             }
             catch (Exception exception6)
             {
                 LOGGER.error("Couldn't handle book info", (Throwable)exception6);
+                this.disconnect("Invalid book data!"); //Craftbukkit
             }
         }
         else if ("MC|BSign".equals(s))
         {
+            //Craftbukkit start
+            if (this.lastBookTick + 20 > MinecraftServer.currentTick) {
+                this.disconnect("Book edited too quickly! If you have problems seeing this message while doing nothing illegal, contact your server admin or open an issue at Lava Github (google it)");
+                return;
+            }
+            this.lastBookTick = MinecraftServer.currentTick;
+            //Craftbukkit end
             PacketBuffer packetbuffer1 = packetIn.getBufferData();
 
             try
@@ -1443,12 +2243,16 @@
                     }
 
                     itemstack2.setTagInfo("pages", nbttaglist);
+                    /* Craftbukkit start - handle it in CraftEvent Factory TODO check and refactor
                     this.player.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, itemstack2);
+                    */
+                    org.bukkit.craftbukkit.event.CraftEventFactory.handleEditBookEvent(player, itemstack2);
                 }
             }
             catch (Exception exception7)
             {
                 LOGGER.error("Couldn't sign book", (Throwable)exception7);
+                this.disconnect("Invalid book data!"); //Craftbukkit
             }
         }
         else if ("MC|TrSel".equals(s))
@@ -1466,6 +2270,7 @@
             catch (Exception exception5)
             {
                 LOGGER.error("Couldn't select trade", (Throwable)exception5);
+                this.disconnect("Invalid trade data!"); //Craftbukkit
             }
         }
         else if ("MC|AdvCmd".equals(s))
@@ -1528,6 +2333,7 @@
             catch (Exception exception4)
             {
                 LOGGER.error("Couldn't set command block", (Throwable)exception4);
+                this.disconnect("Invalid command data!"); //Craftbukkit
             }
         }
         else if ("MC|AutoCmd".equals(s))
@@ -1606,6 +2412,7 @@
             catch (Exception exception3)
             {
                 LOGGER.error("Couldn't set command block", (Throwable)exception3);
+                this.disconnect("Invalid command data!"); //Craftbukkit
             }
         }
         else if ("MC|Beacon".equals(s))
@@ -1632,6 +2439,7 @@
                 catch (Exception exception2)
                 {
                     LOGGER.error("Couldn't set beacon", (Throwable)exception2);
+                    this.disconnect("Invalid beacon data!"); //Craftbukkit
                 }
             }
         }
@@ -1743,6 +2551,7 @@
             catch (Exception exception1)
             {
                 LOGGER.error("Couldn't set structure block", (Throwable)exception1);
+                this.disconnect("Invalid structure data!"); //Craftbukkit
             }
         }
         else if ("MC|PickItem".equals(s))
@@ -1760,7 +2569,125 @@
             catch (Exception exception)
             {
                 LOGGER.error("Couldn't pick item", (Throwable)exception);
+                this.disconnect("Invalid pick item!"); //Craftbukkit
             }
         }
+        // CraftBukkit start
+        else if (packetIn.getChannelName().equals("REGISTER")) {
+            try {
+                String channels = packetIn.getBufferData().toString(com.google.common.base.Charsets.UTF_8);
+                for (String channel : channels.split("\0")) {
+                    getPlayer().addChannel(channel);
+                }
+            } catch (Exception ex) {
+                NetHandlerPlayServer.LOGGER.error("Couldn\'t register custom payload", ex);
+                this.disconnect("Invalid payload REGISTER!");
+            }
+        } else if (packetIn.getChannelName().equals("UNREGISTER")) {
+            try {
+                String channels = packetIn.getBufferData().toString(com.google.common.base.Charsets.UTF_8);
+                for (String channel : channels.split("\0")) {
+                    getPlayer().removeChannel(channel);
+                }
+            } catch (Exception ex) {
+                NetHandlerPlayServer.LOGGER.error("Couldn\'t unregister custom payload", ex);
+                this.disconnect("Invalid payload UNREGISTER!");
+            }
+        } else {
+            try {
+                byte[] data = new byte[packetIn.getBufferData().readableBytes()];
+                packetIn.getBufferData().readBytes(data);
+                server.getMessenger().dispatchIncomingMessage(player.getBukkitEntity(), packetIn.getChannelName(), data);
+            } catch (Exception ex) {
+                NetHandlerPlayServer.LOGGER.error("Couldn\'t dispatch custom payload", ex);
+                this.disconnect("Invalid custom payload!");
+            }
+        }
+        //Craftbukkit end
     }
+    //Craftbukkit methods and fields
+    private static final java.util.concurrent.atomic.AtomicIntegerFieldUpdater<NetHandlerPlayServer> chatSpamField = java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater(NetHandlerPlayServer.class, "chatThrottle");
+    
+    private final org.bukkit.craftbukkit.CraftServer server;
+    
+    private volatile int chatThrottle;
+    
+    private boolean processedDisconnect;
+    private int lastTick = MinecraftServer.currentTick;
+    private int allowedPlayerTicks = 1;
+    private int lastDropTick = MinecraftServer.currentTick;
+    private int lastBookTick = MinecraftServer.currentTick;
+    private int dropCount = 0;
+    private double lastPosX = Double.MAX_VALUE;
+    private double lastPosY = Double.MAX_VALUE;
+    private double lastPosZ = Double.MAX_VALUE;
+    private float lastPitch = Float.MAX_VALUE;
+    private float lastYaw = Float.MAX_VALUE;
+    private boolean justTeleported = false;
+    private org.bukkit.event.player.PlayerTeleportEvent.TeleportCause teleportCause; //Delegate to original teleport with field
+    
+    public final boolean isDisconnected() { return !this.player.joining && !this.netManager.isChannelOpen(); }
+    
+    public org.bukkit.craftbukkit.entity.CraftPlayer getPlayer() { return (this.player == null) ? null : (org.bukkit.craftbukkit.entity.CraftPlayer) this.player.getBukkitEntity(); }
+    
+    public void disconnect(String s) { this.disconnect(new TextComponentTranslation(s)); }
+    
+    public void setPlayerLocation(double d0, double d1, double d2, float f, float f1, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause) {
+        this.teleportCause = cause;
+        this.setPlayerLocation(d0, d1, d2, f, f1, Collections.emptySet());
+    }
+
+    public void setPlayerLocation(double d0, double d1, double d2, float f, float f1, Set<SPacketPlayerPosLook.EnumFlags> set, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause) {
+        this.teleportCause = cause;
+        this.setPlayerLocation(d0, d1, d2, f, f1, set);
+    }
+    
+    // TODO delegate to above method (setPlayerLocation #LN800)
+    public void teleport(org.bukkit.Location dest) { internalTeleport(dest.getX(), dest.getY(), dest.getZ(), dest.getYaw(), dest.getPitch(), Collections.emptySet()); }
+
+    private void internalTeleport(double x, double y, double z, float yaw, float pitch, Set<SPacketPlayerPosLook.EnumFlags> relativeSet) {
+        if (Float.isNaN(yaw)) yaw = 0;
+        if (Float.isNaN(pitch)) pitch = 0;
+        
+        this.justTeleported = true;
+        double d0 = relativeSet.contains(SPacketPlayerPosLook.EnumFlags.X) ? this.player.posX : 0.0D;
+        double d1 = relativeSet.contains(SPacketPlayerPosLook.EnumFlags.Y) ? this.player.posY : 0.0D;
+        double d2 = relativeSet.contains(SPacketPlayerPosLook.EnumFlags.Z) ? this.player.posZ : 0.0D;
+        this.targetPos = new Vec3d(x + d0, y + d1, z + d2);
+        float f = yaw;
+        float f1 = pitch;
+        
+        if (relativeSet.contains(SPacketPlayerPosLook.EnumFlags.Y_ROT)) f = yaw + this.player.rotationYaw;
+        if (relativeSet.contains(SPacketPlayerPosLook.EnumFlags.X_ROT)) f1 = pitch + this.player.rotationPitch;
+        
+        this.lastPosX = this.targetPos.x;
+        this.lastPosY = this.targetPos.y;
+        this.lastPosZ = this.targetPos.z;
+        this.lastYaw = f;
+        this.lastPitch = f1;
+        
+        if (++this.teleportId == Integer.MAX_VALUE) this.teleportId = 0;
+        
+        this.lastPositionUpdate = this.networkTickCount;
+        this.player.setPositionAndRotation(this.targetPos.x, this.targetPos.y, this.targetPos.z, f, f1);
+        this.player.connection.sendPacket(new SPacketPlayerPosLook(x, y, z, yaw, pitch, relativeSet, this.teleportId));
+    }
+    //Craftbukkit method ///Lava-test refactored to fit Forge env
+    public void chat(String s, boolean async) {
+        if (s.isEmpty() || this.player.getChatVisibility() == EntityPlayer.EnumChatVisibility.HIDDEN) return;
+        if (!async && s.startsWith("/")) {
+            this.handleSlashCommand(s);
+            return;
+        }
+        ITextComponent itextcomponent = new TextComponentTranslation("chat.type.text", this.player.getDisplayName(), net.minecraftforge.common.ForgeHooks.newChatWithLinks(s)); //TODO prob doubles the nick
+        net.minecraftforge.event.ServerChatEvent event = new net.minecraftforge.event.ServerChatEvent(this.player, s, itextcomponent, async);
+        
+        if (net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(event)) return;
+        
+        itextcomponent = event.getComponent();
+        
+        if (itextcomponent == null) return;
+        
+        this.serverController.getPlayerList().sendMessage(itextcomponent, false); //TODO support for recipients? huh this logic is weird
+    }
 }
